// ======================================================================
// –ù–ê–ó–í–ê–ù–ò–ï: 074_ESP32_Hub_Async_FreeRTOS_ESP-NOW_Final.ino
// –í–ï–†–°–ò–Ø: 1.1 (–° –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π —É–∑–ª–æ–≤)
// ======================================================================
// –û–ü–ò–°–ê–ù–ò–ï:
// –•–ê–ë –Ω–∞ ESP32-WROOM —Å –≥–∏–±—Ä–∏–¥–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π:
// 1. FreeRTOS: –°–µ—Ä–≤–µ—Ä –Ω–∞ Core 0, –ª–æ–≥–∏–∫–∞ –Ω–∞ Core 1
// 2. AsyncWebServer: –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å –∫–Ω–æ–ø–∫–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É–∑–ª–∞–º–∏
// 3. ESP-NOW: –î–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è —Å–≤—è–∑—å —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º —É–∑–ª–æ–≤
// 4. WebSocket: –†–µ–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
// 5. –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —É–∑–ª–æ–≤ –ø–æ MAC-–∞–¥—Ä–µ—Å–∞–º
// ======================================================================

// ========== –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –ü–ê–ú–Ø–¢–ò ==========
#define ASYNC_WEBSERVER_CONNECTIONS 5
#define ASYNCWEBSERVER_STACK_SIZE 4096

#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <AsyncTCP.h>
#include <esp_now.h>
#include <ArduinoJson.h>

// ========== –ù–ê–°–¢–†–û–ô–ö–ò –°–ï–¢–ò ==========
const char* AP_SSID = "ESP32_Hub_Network";
const char* AP_PASSWORD = "node12345678";

// ========== –ü–†–ï–î–í–ê–†–ò–¢–ï–õ–¨–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ó–í–ï–°–¢–ù–´–• –£–ó–õ–û–í ==========
// –î–û–ë–ê–í–¨–¢–ï –°–Æ–î–ê MAC-–ê–î–†–ï–°–ê –í–ê–®–ò–• –£–ó–õ–û–í –ü–ï–†–ï–î –ü–†–û–®–ò–í–ö–û–ô!
struct PreconfiguredNode {
    uint8_t mac[6];      // MAC-–∞–¥—Ä–µ—Å —É–∑–ª–∞
    uint32_t nodeId;     // ID —É–∑–ª–∞ (2,3,4,5...)
    String name;         // –ß–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
};

PreconfiguredNode knownNodes[] = {
    // –§–æ—Ä–º–∞—Ç: {MAC}, ID, "–ù–∞–∑–≤–∞–Ω–∏–µ"
    {{0x88, 0x56, 0xA6, 0x7C, 0xF2, 0xA8}, 2, "–£–∑–µ–ª #2"},  // ESP32-C3 #2
    {{0x88, 0x56, 0xA6, 0x7D, 0x09, 0x64}, 3, "–£–∑–µ–ª #3"},  // ESP32-C3 #3
    {{0x10, 0x00, 0x3B, 0xB1, 0xA6, 0x9C}, 4, "–£–∑–µ–ª #4"},  // ESP32-C3 #4
    {{0xAC, 0xEB, 0xE6, 0x49, 0x10, 0x28}, 5, "–£–∑–µ–ª #5"},  // ESP32-C3 #5
    // –î–æ–±–∞–≤—å—Ç–µ —Å—é–¥–∞ –Ω–æ–≤—ã–µ —É–∑–ª—ã –ø–æ –º–µ—Ä–µ –ø–æ—è–≤–ª–µ–Ω–∏—è
    // {{0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX}, ID, "–ù–∞–∑–≤–∞–Ω–∏–µ"},
};

const int KNOWN_NODES_COUNT = sizeof(knownNodes) / sizeof(knownNodes[0]);

// ========== –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• ==========

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è ESP-NOW —Å–æ–æ–±—â–µ–Ω–∏–π (–¥–æ–ª–∂–Ω–∞ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å —É–∑–ª–æ–º!)
typedef struct esp_now_message {
    char command[16];      // "LED_ON", "LED_OFF", "ACK_ON", "ACK_OFF", –∏ —Ç.–¥.
    uint8_t sender_id;     // ID –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
    uint8_t target_id;     // ID —Ü–µ–ª–µ–≤–æ–≥–æ —É–∑–ª–∞ (0 = –≤—Å–µ–º)
} esp_now_message;

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞ –≤ —Ö–∞–±–µ
struct NodeData {
    // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    String ip;                     // IP –∞–¥—Ä–µ—Å (–µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω –ø–æ Wi-Fi)
    uint32_t nodeId = 0;           // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —É–∑–ª–∞
    uint8_t mac[6] = {0};          // MAC –∞–¥—Ä–µ—Å —É–∑–ª–∞
    String name = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π";   // –ò–º—è —É–∑–ª–∞
    bool preconfigured = false;    // –£–∑–µ–ª –∏–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    bool espNowRegistered = false; // –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ ESP-NOW
    
    // –î–∞–Ω–Ω—ã–µ –¥–∞—Ç—á–∏–∫–æ–≤
    float tempAHT = NAN;
    float lastTempAHT = NAN;
    float humAHT = NAN;
    float tempBMP = NAN;
    float pressBMP = NAN;
    int rssi = 0;
    int chain1 = 0;
    int chain2 = 0;
    int chain3 = 0;
    
    // –°—Ç–∞—Ç—É—Å –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    unsigned long lastSeen = 0;
    bool online = false;
    bool alarmFlag = false;
    String lastCommand = "";       // –ü–æ—Å–ª–µ–¥–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —É–∑–ª—É
    String lastAck = "";           // –ü–æ—Å–ª–µ–¥–Ω–µ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    unsigned long lastCommandTime = 0;
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã—Ö–æ–¥–æ–≤ (–¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ)
    bool ledState = false;
    bool relay1State = false;
    bool relay2State = false;
};

// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
NodeData nodes[10];                // –ú–∞–∫—Å–∏–º—É–º 10 —É–∑–ª–æ–≤
int nodeCount = 0;
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");          // WebSocket –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
TaskHandle_t ServerTaskHandle;
SemaphoreHandle_t xNodesSemaphore;

// –ë—É—Ñ–µ—Ä—ã –¥–ª—è ESP-NOW
esp_now_message outgoingMessage;
esp_now_message incomingMessage;

// ========== –ü–†–û–¢–û–¢–ò–ü–´ –§–£–ù–ö–¶–ò–ô ==========
void registerPreconfiguredNodes();
String getNodeTableRows();
String getWebInterface();
void printNodeToSerial(NodeData &node, bool isEmergency = false);
int findOrCreateNode(String ip, uint32_t nodeId);
int findNodeByMac(const uint8_t* mac);
int findNodeById(uint32_t nodeId);
void updateWebInterface();
void sendEspNowCommand(uint32_t targetNodeId, String command);
void broadcastStatus(String statusText);
void handleApiStatusRequest(AsyncWebServerRequest *request);
void handleNotFoundRequest(AsyncWebServerRequest *request);
void serverTask(void *pvParameters);

// ESP-NOW –∫–æ–ª–±—ç–∫–∏
void onEspNowDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status);
void onEspNowDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *incomingData, int len);

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ WebSocket
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, 
                      AwsEventType type, void *arg, uint8_t *data, size_t len);

// ========== SETUP (–Ø–î–†–û 1) ==========
void setup() {
    Serial.begin(115200);
    delay(1000);

    // –°–æ–∑–¥–∞–µ–º —Å–µ–º–∞—Ñ–æ—Ä –¥–ª—è –∑–∞—â–∏—Ç—ã –æ–±—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
    xNodesSemaphore = xSemaphoreCreateMutex();
    if (xNodesSemaphore == NULL) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞!");
        while (1) delay(1000);
    }

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Wi-Fi –≤ –≥–∏–±—Ä–∏–¥–Ω–æ–º —Ä–µ–∂–∏–º–µ AP+STA (–¥–ª—è ESP-NOW)
    WiFi.mode(WIFI_AP_STA);
    WiFi.setTxPower(WIFI_POWER_8_5dBm);

    Serial.println("\n=== ESP32 –•–ê–ë (FreeRTOS + ESP-NOW + WebSocket) ===");
    Serial.println("–í–µ—Ä—Å–∏—è: –ì–∏–±—Ä–∏–¥–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è v1.1");
    Serial.println("–°–µ—Ä–≤–µ—Ä –Ω–∞ Core 0, ESP-NOW –ª–æ–≥–∏–∫–∞ –Ω–∞ Core 1");
    Serial.print("–ò–∑–≤–µ—Å—Ç–Ω—ã—Ö —É–∑–ª–æ–≤: ");
    Serial.println(KNOWN_NODES_COUNT);

    // –ó–∞–ø—É—Å–∫ —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞
    if (!WiFi.softAP(AP_SSID, AP_PASSWORD)) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞!");
        while (1) delay(1000);
    }

    Serial.print("IP —Ö–∞–±–∞: ");
    Serial.println(WiFi.softAPIP());
    Serial.print("MAC —Ö–∞–±–∞: ");
    Serial.println(WiFi.softAPmacAddress());

    // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ESP-NOW ==========
    if (esp_now_init() != ESP_OK) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ESP-NOW!");
        while(1) delay(1000);
    }
    
    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–ª–±—ç–∫–æ–≤ ESP-NOW
    esp_now_register_send_cb(onEspNowDataSent);
    esp_now_register_recv_cb(onEspNowDataRecv);
    
    Serial.println("‚úÖ ESP-NOW –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");

    // ========== –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –ü–†–ï–î–ù–ê–°–¢–†–û–ï–ù–ù–´–• –£–ó–õ–û–í ==========
    registerPreconfiguredNodes();
	    // ========== –ù–ê–°–¢–†–û–ô–ö–ê WEB-–ò–ù–¢–ï–†–§–ï–ô–°–ê ==========
    
    // –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send(200, "text/html", getWebInterface());
    });

    // API –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã —É–∑–ª–æ–≤ (AJAX)
    server.on("/api/table", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
            String tableRows = getNodeTableRows();
            xSemaphoreGive(xNodesSemaphore);
            request->send(200, "text/html", tableRows);
        } else {
            request->send(503, "text/plain", "Service Unavailable");
        }
    });

    // API –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥ —É–∑–ª–∞–º
    server.on("/api/command", HTTP_POST, [](AsyncWebServerRequest *request) {
        if (request->hasParam("nodeId", true) && request->hasParam("command", true)) {
            String nodeIdStr = request->getParam("nodeId", true)->value();
            String command = request->getParam("command", true)->value();
            
            uint32_t nodeId = nodeIdStr.toInt();
            
            if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                sendEspNowCommand(nodeId, command);
                xSemaphoreGive(xNodesSemaphore);
                
                JsonDocument resp;
                resp["status"] = "ok";
                resp["message"] = "–ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —É–∑–ª—É " + String(nodeId);
                String response;
                serializeJson(resp, response);
                request->send(200, "application/json", response);
            }
        } else {
            request->send(400, "text/plain", "Missing parameters");
        }
    });

    // –ü—Ä–∏–µ–º –¥–∞–Ω–Ω—ã—Ö –æ—Ç —É–∑–ª–æ–≤ –ø–æ HTTP (POST /data)
    server.on("/data", HTTP_POST, 
        [](AsyncWebServerRequest *request) {},
        NULL,
        [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
            if (index == 0 && len > 0) {
                String body = String((char*)data, len);
                String clientIP = request->client()->remoteIP().toString();
                
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) {
                    request->send(400, "text/plain", "JSON error");
                    return;
                }
                
                uint32_t nodeId = doc["nodeId"] | 0;
                
                if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                    int idx = findOrCreateNode(clientIP, nodeId);
                    
                    if (idx != -1) {
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞
                        nodes[idx].lastTempAHT = nodes[idx].tempAHT;
                        nodes[idx].tempAHT = doc["tempAHT"] | NAN;
                        nodes[idx].humAHT = doc["humAHT"] | NAN;
                        nodes[idx].tempBMP = doc["tempBMP"] | NAN;
                        nodes[idx].pressBMP = doc["pressBMP"] | NAN;
                        nodes[idx].rssi = doc["rssi"] | 0;
                        nodes[idx].chain1 = doc["chain1"] | 0;
                        nodes[idx].chain2 = doc["chain2"] | 0;
                        nodes[idx].chain3 = doc["chain3"] | 0;
                        nodes[idx].lastSeen = millis();
                        nodes[idx].online = true;
                        
                        printNodeToSerial(nodes[idx], false);
                        updateWebInterface();
                    }
                    xSemaphoreGive(xNodesSemaphore);
                }
                
                JsonDocument resp;
                resp["status"] = "ok";
                String response;
                serializeJson(resp, response);
                request->send(200, "application/json", response);
            }
        }
    );

    // –ü—Ä–∏–µ–º –∞–≤–∞—Ä–∏–π–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    server.on("/emergency", HTTP_POST,
        [](AsyncWebServerRequest *request) {},
        NULL,
        [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
            if (index == 0 && len > 0) {
                String body = String((char*)data, len);
                String clientIP = request->client()->remoteIP().toString();
                
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) return;
                
                uint32_t nodeId = doc["nodeId"] | 0;
                int chain1 = doc["chain1"] | 0;
                int chain2 = doc["chain2"] | 0;
                int chain3 = doc["chain3"] | 0;
                
                if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                    int idx = findNodeById(nodeId);
                    if (idx == -1) idx = findOrCreateNode(clientIP, nodeId);
                    
                    if (idx != -1) {
                        nodes[idx].chain1 = chain1;
                        nodes[idx].chain2 = chain2;
                        nodes[idx].chain3 = chain3;
                        nodes[idx].lastSeen = millis();
                        nodes[idx].online = true;
                        nodes[idx].alarmFlag = true;
                        
                        Serial.print("üö® –ê–í–ê–†–ò–Ø: ");
                        Serial.print(nodes[idx].name);
                        Serial.print(" —Ü–µ–ø–∏:[");
                        Serial.print(chain1);
                        Serial.print(",");
                        Serial.print(chain2);
                        Serial.print(",");
                        Serial.print(chain3);
                        Serial.println("]");
                        
                        updateWebInterface();
                    }
                    xSemaphoreGive(xNodesSemaphore);
                }
                
                request->send(200, "text/plain", "emergency received");
            }
        }
    );

    // API —Å—Ç–∞—Ç—É—Å–∞ (JSON)
    server.on("/api/status", HTTP_GET, handleApiStatusRequest);
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ 404
    server.onNotFound(handleNotFoundRequest);

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ WebSocket
    ws.onEvent(onWebSocketEvent);
    server.addHandler(&ws);

    // ========== –°–û–ó–î–ê–ù–ò–ï –ó–ê–î–ê–ß–ò –î–õ–Ø –°–ï–†–í–ï–†–ê –ù–ê –Ø–î–†–ï 0 ==========
    xTaskCreatePinnedToCore(
        serverTask,
        "AsyncWebServer",
        ASYNCWEBSERVER_STACK_SIZE,
        NULL,
        1,
        &ServerTaskHandle,
        0
    );

    Serial.println("‚úÖ –ó–∞–¥–∞—á–∞ —Å–µ—Ä–≤–µ—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ –Ω–∞ Core 0");
    Serial.println("‚úÖ –•–∞–± –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ (Wi-Fi + ESP-NOW)\n");
}

// ========== –§–£–ù–ö–¶–ò–Ø –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò –ü–†–ï–î–ù–ê–°–¢–†–û–ï–ù–ù–´–• –£–ó–õ–û–í ==========
void registerPreconfiguredNodes() {
    Serial.println("üìã –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤:");
    
    for (int i = 0; i < KNOWN_NODES_COUNT; i++) {
        // 1. –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª –≤ ESP-NOW –ø–∏—Ä—ã
        esp_now_peer_info_t peerInfo = {};
        memcpy(peerInfo.peer_addr, knownNodes[i].mac, 6);
        peerInfo.channel = 0;
        peerInfo.encrypt = false;
        
        if (esp_now_add_peer(&peerInfo) == ESP_OK) {
            // 2. –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª –≤ –Ω–∞—à—É –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é –±–∞–∑—É
            if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                if (nodeCount < 10) {
                    int idx = nodeCount;
                    memcpy(nodes[idx].mac, knownNodes[i].mac, 6);
                    nodes[idx].nodeId = knownNodes[i].nodeId;
                    nodes[idx].name = knownNodes[i].name;
                    nodes[idx].preconfigured = true;
                    nodes[idx].espNowRegistered = true;
                    nodes[idx].lastSeen = 0;
                    nodes[idx].online = false;
                    nodeCount++;
                    
                    Serial.print("  ‚úÖ ");
                    Serial.print(knownNodes[i].name);
                    Serial.print(" (ID:");
                    Serial.print(knownNodes[i].nodeId);
                    Serial.print(") MAC:");
                    for(int j=0; j<6; j++) {
                        Serial.print(knownNodes[i].mac[j], HEX);
                        if(j<5) Serial.print(":");
                    }
                    Serial.println();
                } else {
                    Serial.print("  ‚ùå –õ–∏–º–∏—Ç —É–∑–ª–æ–≤! –ù–µ –¥–æ–±–∞–≤–ª–µ–Ω: ");
                    Serial.println(knownNodes[i].name);
                }
                xSemaphoreGive(xNodesSemaphore);
            }
        } else {
            Serial.print("  ‚ùå –û—à–∏–±–∫–∞ ESP-NOW –¥–ª—è ");
            Serial.println(knownNodes[i].name);
        }
    }
    Serial.println("üìã –í—Å–µ–≥–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ —É–∑–ª–æ–≤: " + String(nodeCount));
}

// ========== –ó–ê–î–ê–ß–ê –°–ï–†–í–ï–†–ê (–Ø–î–†–û 0) ==========
void serverTask(void *pvParameters) {
    Serial.print("–ó–∞–¥–∞—á–∞ —Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ —è–¥—Ä–µ: ");
    Serial.println(xPortGetCoreID());
    
    server.begin();
    
    for(;;) {
        ws.cleanupClients(); // –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö WebSocket –∫–ª–∏–µ–Ω—Ç–æ–≤
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
// ========== LOOP (–Ø–î–†–û 1) ==========
void loop() {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–Ω–ª–∞–π–Ω-—Å—Ç–∞—Ç—É—Å–∞ —É–∑–ª–æ–≤
    static unsigned long lastStatusCheck = 0;
    if (millis() - lastStatusCheck > 30000) {
        lastStatusCheck = millis();
        
        if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
            for (int i = 0; i < nodeCount; i++) {
                bool wasOnline = nodes[i].online;
                nodes[i].online = (millis() - nodes[i].lastSeen < 60000);
                
                // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–∏–ª—Å—è - –æ–±–Ω–æ–≤–ª—è–µ–º –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                if (wasOnline != nodes[i].online) {
                    updateWebInterface();
                }
            }
            xSemaphoreGive(xNodesSemaphore);
            
            // –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø–∞–º—è—Ç–∏
            static int logCounter = 0;
            if (++logCounter % 5 == 0) {
                Serial.printf("[MEM] –°–≤–æ–±–æ–¥–Ω–æ: %.1f KB | Min: %.1f KB\n", 
                    ESP.getFreeHeap() / 1024.0, 
                    ESP.getMinFreeHeap() / 1024.0);
            }
        }
    }
    
    delay(100);
}

// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
String getWebInterface() {
    String html = R"rawliteral(
<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ESP32 –•–∞–± - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É–∑–ª–∞–º–∏</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
    .container { max-width: 1400px; margin: auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    .alarm-row { background-color: #ffeeee !important; border-left: 5px solid #e74c3c; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
    th { background: #3498db; color: white; }
    .online { color: #27ae60; font-weight: bold; }
    .offline { color: #e74c3c; font-weight: bold; }
    .command-btn { padding: 6px 12px; margin: 2px; border: none; border-radius: 4px; cursor: pointer; }
    .btn-on { background: #4CAF50; color: white; }
    .btn-off { background: #f44336; color: white; }
    .btn-relay { background: #2196F3; color: white; }
    .update-info { font-size: 0.9em; color: #7f8c8d; text-align: right; margin-top: 10px; }
    .status-ack { font-size: 0.8em; color: #666; margin-top: 3px; }
    .led-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
    .led-on { background-color: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
    .led-off { background-color: #ccc; }
</style>
<script>
const ws = new WebSocket('ws://' + window.location.hostname + '/ws');
ws.onopen = function() {
    console.log('WebSocket connected');
    updateTable();
};
ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    if(data.type === 'status') {
        updateStatus(data);
    } else if(data.type === 'table_update') {
        document.getElementById('nodes-tbody').innerHTML = data.html;
        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
        document.getElementById('node-count').textContent = document.querySelectorAll('#nodes-tbody tr').length;
    }
};
function sendCommand(nodeId, command) {
    fetch('/api/command', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'nodeId=' + nodeId + '&command=' + command
    }).then(r => r.json()).then(data => {
        console.log('Command sent:', data);
    });
}
function updateTable() {
    fetch('/api/table')
        .then(r => r.text())
        .then(html => {
            document.getElementById('nodes-tbody').innerHTML = html;
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
            document.getElementById('node-count').textContent = document.querySelectorAll('#nodes-tbody tr').length;
        });
}
function updateStatus(data) {
    console.log('Status update:', data);
}
setInterval(updateTable, 10000);
</script>
</head><body>
<div class="container">
    <h1>üì∂ ESP32 –•–∞–± - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É–∑–ª–∞–º–∏ (ESP-NOW + WebSocket)</h1>
    <p><strong>–°–µ—Ç—å:</strong> )rawliteral";
    html += AP_SSID;
    html += R"rawliteral( | <strong>IP:</strong> )rawliteral";
    html += WiFi.softAPIP().toString();
    html += R"rawliteral( | <strong>–£–∑–ª–æ–≤:</strong> <span id="node-count">0</span></p>
    <hr>
    <table>
        <thead><tr>
            <th>–£–∑–µ–ª</th><th>–°—Ç–∞—Ç—É—Å</th><th>–î–∞—Ç—á–∏–∫–∏</th><th>–¶–µ–ø–∏</th>
            <th>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</th><th>RSSI</th><th>–û–±–Ω–æ–≤–ª–µ–Ω–æ</th>
        </tr></thead>
        <tbody id="nodes-tbody"><tr><td colspan="7">–ó–∞–≥—Ä—É–∑–∫–∞...</td></tbody>
    </table>
    <div class="update-info">–û–±–Ω–æ–≤–ª–µ–Ω–æ: <span id="last-update">--:--:--</span></div>
</div>
</body></html>
)rawliteral";
    return html;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã —É–∑–ª–æ–≤
String getNodeTableRows() {
    if (nodeCount == 0) {
        return "<tr><td colspan='7' style='text-align:center;'>‚è≥ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —É–∑–ª–æ–≤</td></tr>";
    }
    
    String rowsHTML = "";
    for (int i = 0; i < nodeCount; i++) {
        String rowClass = nodes[i].alarmFlag ? "class='alarm-row'" : "";
        String status = nodes[i].online ? 
            "<span class='online'>‚óè ONLINE</span>" : 
            "<span class='offline'>‚óè OFFLINE</span>";
        
        // –î–∞–Ω–Ω—ã–µ –¥–∞—Ç—á–∏–∫–æ–≤
        String sensors = "";
        if (!isnan(nodes[i].tempAHT)) {
            sensors += "AHT: " + String(nodes[i].tempAHT,1) + "¬∞C " + 
                      String(nodes[i].humAHT,1) + "%<br>";
        }
        if (!isnan(nodes[i].tempBMP)) {
            sensors += "BMP: " + String(nodes[i].tempBMP,1) + "¬∞C " +
                      String(nodes[i].pressBMP,1) + "–º–º";
        }
        if (sensors == "") sensors = "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö";
        
        // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ü–µ–ø–µ–π
        String chains = "<span style='color:" + String(nodes[i].chain1==0?"#27ae60":"#e74c3c") + 
                       "'>1:" + (nodes[i].chain1==0?"OK":"AL") + "</span> ";
        chains += "<span style='color:" + String(nodes[i].chain2==0?"#27ae60":"#e74c3c") + 
                 "'>2:" + (nodes[i].chain2==0?"OK":"AL") + "</span> ";
        chains += "<span style='color:" + String(nodes[i].chain3==0?"#27ae60":"#e74c3c") + 
                 "'>3:" + (nodes[i].chain3==0?"OK":"AL") + "</span>";
        
        // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ—Å—Ç–æ—è–Ω–∏—è
        String controls = "<div>";
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä LED
        controls += "<span class='led-indicator " + String(nodes[i].ledState?"led-on":"led-off") + "'></span>";
        controls += "<button class='command-btn " + String(nodes[i].ledState?"btn-off":"btn-on") + 
                   "' onclick='sendCommand(" + String(nodes[i].nodeId) + ", \"" + 
                   (nodes[i].ledState?"LED_OFF":"LED_ON") + "\")'>" + 
                   (nodes[i].ledState?"LED –í–´–ö–õ":"LED –í–ö–õ") + "</button>";
        
        controls += "<br>";
        
        // –ö–Ω–æ–ø–∫–∏ —Ä–µ–ª–µ
        controls += "<button class='command-btn btn-relay' onclick='sendCommand(" + 
                   String(nodes[i].nodeId) + ", \"RELAY_1_ON\")'>–†–ï–õ–ï 1 –í–ö–õ</button>";
        controls += "<button class='command-btn btn-relay' onclick='sendCommand(" + 
                   String(nodes[i].nodeId) + ", \"RELAY_1_OFF\")'>–†–ï–õ–ï 1 –í–´–ö–õ</button>";
        
        controls += "</div>";
        
        // –°—Ç–∞—Ç—É—Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã
        if (nodes[i].lastAck != "") {
            controls += "<div class='status-ack'>" + nodes[i].lastAck + "</div>";
        }
        
        // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        unsigned long secAgo = (millis() - nodes[i].lastSeen) / 1000;
        String timeText;
        if (secAgo < 60) {
            timeText = String(secAgo) + " —Å–µ–∫";
        } else if (secAgo < 3600) {
            timeText = String(secAgo / 60) + " –º–∏–Ω";
        } else {
            timeText = String(secAgo / 3600) + " —á";
        }
        
        // –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏
        rowsHTML += "<tr " + rowClass + ">";
        rowsHTML += "<td><strong>" + nodes[i].name + "</strong><br>";
        rowsHTML += "<small>ID: " + String(nodes[i].nodeId) + " | ";
        rowsHTML += "MAC: ";
        for(int j=0; j<6; j++) {
            rowsHTML += String(nodes[i].mac[j], HEX);
            if(j<5) rowsHTML += ":";
        }
        rowsHTML += "</small></td>";
        rowsHTML += "<td>" + status + "</td>";
        rowsHTML += "<td>" + sensors + "</td>";
        rowsHTML += "<td>" + chains + "</td>";
        rowsHTML += "<td>" + controls + "</td>";
        rowsHTML += "<td>" + String(nodes[i].rssi) + " dBm</td>";
        rowsHTML += "<td>" + timeText + " –Ω–∞–∑–∞–¥</td>";
        rowsHTML += "</tr>";
    }
    return rowsHTML;
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —á–µ—Ä–µ–∑ WebSocket
void updateWebInterface() {
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        String tableRows = getNodeTableRows();
        xSemaphoreGive(xNodesSemaphore);
        
        JsonDocument doc;
        doc["type"] = "table_update";
        doc["html"] = tableRows;
        
        String jsonResponse;
        serializeJson(doc, jsonResponse);
        ws.textAll(jsonResponse);
    }
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã —É–∑–ª—É –ø–æ ESP-NOW
void sendEspNowCommand(uint32_t targetNodeId, String command) {
    int nodeIndex = findNodeById(targetNodeId);
    if (nodeIndex == -1) {
        Serial.print("‚ùå –£–∑–µ–ª ID ");
        Serial.print(targetNodeId);
        Serial.println(" –Ω–µ –Ω–∞–π–¥–µ–Ω!");
        return;
    }
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–æ–º–∞–Ω–¥—ã
    strncpy(outgoingMessage.command, command.c_str(), sizeof(outgoingMessage.command)-1);
    outgoingMessage.sender_id = 0; // ID —Ö–∞–±–∞
    outgoingMessage.target_id = targetNodeId;
    
    if (nodes[nodeIndex].espNowRegistered) {
        esp_err_t result = esp_now_send(nodes[nodeIndex].mac, 
                                       (uint8_t *) &outgoingMessage, 
                                       sizeof(outgoingMessage));
        
        if (result == ESP_OK) {
            Serial.print("üì° –ö–æ–º–∞–Ω–¥–∞ '");
            Serial.print(command);
            Serial.print("' –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ ");
            Serial.print(nodes[nodeIndex].name);
            Serial.print(" (ID:");
            Serial.print(targetNodeId);
            Serial.println(")");
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —É–∑–ª–∞
            nodes[nodeIndex].lastCommand = command;
            nodes[nodeIndex].lastCommandTime = millis();
            
            // –ü—Ä–µ–¥—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–∂–∏–¥–∞–µ–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            if (command == "LED_ON") nodes[nodeIndex].ledState = true;
            else if (command == "LED_OFF") nodes[nodeIndex].ledState = false;
            else if (command == "RELAY_1_ON") nodes[nodeIndex].relay1State = true;
            else if (command == "RELAY_1_OFF") nodes[nodeIndex].relay1State = false;
            
            updateWebInterface(); // –ë—ã—Å—Ç—Ä–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        } else {
            Serial.print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ESP-NOW: ");
            Serial.println(result);
        }
    } else {
        Serial.print("‚ö†Ô∏è ");
        Serial.print(nodes[nodeIndex].name);
        Serial.println(" –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ ESP-NOW");
    }
}

// –ö–æ–ª–±—ç–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ ESP-NOW
void onEspNowDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status) {
    Serial.print("‚úâÔ∏è –î–æ—Å—Ç–∞–≤–∫–∞ ESP-NOW: ");
    Serial.println(status == ESP_NOW_SEND_SUCCESS ? "–£—Å–ø–µ—Ö" : "–û—à–∏–±–∫–∞");
}

// –ö–æ–ª–±—ç–∫ –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ ESP-NOW
void onEspNowDataRecv(const esp_now_recv_info_t *recv_info, 
                     const uint8_t *incomingData, int len) {
    const uint8_t *senderMac = recv_info->src_addr;
    memcpy(&incomingMessage, incomingData, min(len, (int)sizeof(incomingMessage)));
    
    // –ü–æ–∏—Å–∫ —É–∑–ª–∞ –ø–æ MAC
    int nodeIndex = findNodeByMac(senderMac);
    
    if (nodeIndex == -1) {
        // –ù–æ–≤—ã–π —É–∑–µ–ª - —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º
        if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
            if (nodeCount < 10) {
                nodeIndex = nodeCount;
                memcpy(nodes[nodeIndex].mac, senderMac, 6);
                nodes[nodeIndex].nodeId = incomingMessage.sender_id;
                nodes[nodeIndex].name = "–£–∑–µ–ª #" + String(incomingMessage.sender_id);
                nodes[nodeIndex].espNowRegistered = true;
                nodes[nodeIndex].lastSeen = millis();
                nodes[nodeIndex].online = true;
                nodeCount++;
                
                // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ ESP-NOW
                esp_now_peer_info_t peerInfo = {};
                memcpy(peerInfo.peer_addr, senderMac, 6);
                peerInfo.channel = 0;
                peerInfo.encrypt = false;
                esp_now_add_peer(&peerInfo);
                
                Serial.print("üîó –ù–æ–≤—ã–π —É–∑–µ–ª –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω: ");
                Serial.print(nodes[nodeIndex].name);
                Serial.print(" MAC:");
                for(int i=0; i<6; i++) {
                    Serial.print(senderMac[i], HEX);
                    if(i<5) Serial.print(":");
                }
                Serial.println();
                
                updateWebInterface();
            }
            xSemaphoreGive(xNodesSemaphore);
        }
    }
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π –æ—Ç —É–∑–ª–æ–≤
    if (nodeIndex != -1) {
        if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
            nodes[nodeIndex].lastSeen = millis();
            nodes[nodeIndex].online = true;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è–º
            if (strcmp(incomingMessage.command, "ACK_ON") == 0) {
                nodes[nodeIndex].ledState = true;
                nodes[nodeIndex].lastAck = "LED –í–ö–õ (" + String(millis() - nodes[nodeIndex].lastCommandTime) + "–º—Å)";
                Serial.print("‚úÖ ");
                Serial.print(nodes[nodeIndex].name);
                Serial.println(": LED –í–ö–õ–Æ–ß–ï–ù");
                
            } else if (strcmp(incomingMessage.command, "ACK_OFF") == 0) {
                nodes[nodeIndex].ledState = false;
                nodes[nodeIndex].lastAck = "LED –í–´–ö–õ (" + String(millis() - nodes[nodeIndex].lastCommandTime) + "–º—Å)";
                Serial.print("‚úÖ ");
                Serial.print(nodes[nodeIndex].name);
                Serial.println(": LED –í–´–ö–õ–Æ–ß–ï–ù");
                
            } else if (strcmp(incomingMessage.command, "ACK_RELAY1_ON") == 0) {
                nodes[nodeIndex].relay1State = true;
                nodes[nodeIndex].lastAck = "–†–ï–õ–ï 1 –í–ö–õ (" + String(millis() - nodes[nodeIndex].lastCommandTime) + "–º—Å)";
                Serial.print("‚úÖ ");
                Serial.print(nodes[nodeIndex].name);
                Serial.println(": –†–ï–õ–ï 1 –í–ö–õ–Æ–ß–ï–ù–û");
                
            } else if (strcmp(incomingMessage.command, "ACK_RELAY1_OFF") == 0) {
                nodes[nodeIndex].relay1State = false;
                nodes[nodeIndex].lastAck = "–†–ï–õ–ï 1 –í–´–ö–õ (" + String(millis() - nodes[nodeIndex].lastCommandTime) + "–º—Å)";
                Serial.print("‚úÖ ");
                Serial.print(nodes[nodeIndex].name);
                Serial.println(": –†–ï–õ–ï 1 –í–´–ö–õ–Æ–ß–ï–ù–û");
            }
            
            xSemaphoreGive(xNodesSemaphore);
            updateWebInterface();
        }
    }
}

// –ü–æ–∏—Å–∫ —É–∑–ª–∞ –ø–æ MAC –∞–¥—Ä–µ—Å—É
int findNodeByMac(const uint8_t* mac) {
    for (int i = 0; i < nodeCount; i++) {
        if (memcmp(nodes[i].mac, mac, 6) == 0) {
            return i;
        }
    }
    return -1;
}

// –ü–æ–∏—Å–∫ —É–∑–ª–∞ –ø–æ ID
int findNodeById(uint32_t nodeId) {
    for (int i = 0; i < nodeCount; i++) {
        if (nodes[i].nodeId == nodeId) {
            return i;
        }
    }
    return -1;
}

// –ü–æ–∏—Å–∫ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ —É–∑–ª–∞ –ø–æ IP –∏ ID
int findOrCreateNode(String ip, uint32_t nodeId) {
    // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø–æ ID
    for (int i = 0; i < nodeCount; i++) {
        if (nodes[i].nodeId == nodeId) {
            nodes[i].ip = ip;
            return i;
        }
    }
    
    // –ó–∞—Ç–µ–º –∏—â–µ–º –ø–æ IP
    for (int i = 0; i < nodeCount; i++) {
        if (nodes[i].ip == ip) {
            nodes[i].nodeId = nodeId;
            return i;
        }
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª
    if (nodeCount < 10) {
        int idx = nodeCount;
        nodes[idx].ip = ip;
        nodes[idx].nodeId = nodeId;
        nodes[idx].name = "–£–∑–µ–ª #" + String(nodeId);
        nodes[idx].lastSeen = millis();
        nodes[idx].online = true;
        nodeCount++;
        
        Serial.print("üì° –ù–æ–≤—ã–π —É–∑–µ–ª (HTTP): ");
        Serial.print(ip);
        Serial.print(" ID:");
        Serial.println(nodeId);
        
        return idx;
    }
    
    Serial.println("‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —É–∑–ª–æ–≤ (10)!");
    return -1;
}

// –í—ã–≤–æ–¥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É–∑–ª–µ –≤ Serial
void printNodeToSerial(NodeData &node, bool isEmergency) {
    Serial.print(isEmergency ? "üö® –ê–í–ê–†–ò–Ø: " : "üìä ");
    Serial.print(node.name);
    Serial.print(" (ID:");
    Serial.print(node.nodeId);
    Serial.print(") | ");
    
    if (!isnan(node.tempAHT)) {
        Serial.print("AHT:");
        Serial.print(node.tempAHT,1);
        Serial.print("C/");
        Serial.print(node.humAHT,1);
        Serial.print("% ");
    }
    
    if (!isnan(node.tempBMP)) {
        Serial.print("BMP:");
        Serial.print(node.tempBMP,1);
        Serial.print("C/");
        Serial.print(node.pressBMP,1);
        Serial.print("mmHg ");
    }
    
    Serial.print("–¶–µ–ø–∏:[");
    Serial.print(node.chain1);
    Serial.print(",");
    Serial.print(node.chain2);
    Serial.print(",");
    Serial.print(node.chain3);
    Serial.print("] RSSI:");
    Serial.print(node.rssi);
    Serial.println("dBm");
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ API —Å—Ç–∞—Ç—É—Å–∞
void handleApiStatusRequest(AsyncWebServerRequest *request) {
    JsonDocument doc;
    JsonArray nodesArray = doc["nodes"].to<JsonArray>();
    
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < nodeCount; i++) {
            JsonObject nodeObj = nodesArray.add<JsonObject>();
            nodeObj["name"] = nodes[i].name;
            nodeObj["nodeId"] = nodes[i].nodeId;
            nodeObj["online"] = nodes[i].online;
            nodeObj["ip"] = nodes[i].ip;
            nodeObj["tempAHT"] = nodes[i].tempAHT;
            nodeObj["humAHT"] = nodes[i].humAHT;
            nodeObj["tempBMP"] = nodes[i].tempBMP;
            nodeObj["pressBMP"] = nodes[i].pressBMP;
            nodeObj["chain1"] = nodes[i].chain1;
            nodeObj["chain2"] = nodes[i].chain2;
            nodeObj["chain3"] = nodes[i].chain3;
            nodeObj["rssi"] = nodes[i].rssi;
            nodeObj["alarmFlag"] = nodes[i].alarmFlag;
            nodeObj["ledState"] = nodes[i].ledState;
            nodeObj["relay1State"] = nodes[i].relay1State;
            nodeObj["lastSeen"] = nodes[i].lastSeen;
        }
        xSemaphoreGive(xNodesSemaphore);
    }
    
    doc["hub"]["freeHeap"] = ESP.getFreeHeap();
    doc["hub"]["uptime"] = millis();
    doc["hub"]["nodeCount"] = nodeCount;
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ 404
void handleNotFoundRequest(AsyncWebServerRequest *request) {
    request->send(404, "text/plain", "404: Not Found");
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π WebSocket
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, 
                      AwsEventType type, void *arg, uint8_t *data, size_t len) {
    if (type == WS_EVT_DATA) {
        JsonDocument doc;
        DeserializationError error = deserializeJson(doc, data, len);
        if (!error && doc.containsKey("command") && doc.containsKey("nodeId")) {
            String cmd = doc["command"].as<String>();
            uint32_t nodeId = doc["nodeId"];
            
            if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                sendEspNowCommand(nodeId, cmd);
                xSemaphoreGive(xNodesSemaphore);
            }
        }
    }
}

// ======================================================================
// –ö–û–ù–ï–¶ –°–ö–ï–¢–ß–ê –•–ê–ë–ê
// ======================================================================
