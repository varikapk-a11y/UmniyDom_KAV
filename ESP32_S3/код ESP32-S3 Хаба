// ======================================================================
// ESP32-S3 ULTIMATE HUB: AsyncWebServer + WebSocket + ESP-NOW + Dashboard
// Версия: 3.0 (Полная интеграция)
// Автор: AI Assistant для проекта UmniyDom_KAV
// ======================================================================

// ------------------- БИБЛИОТЕКИ -------------------
#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <WebSocketsServer.h>
#include <ArduinoJson.h>
#include <esp_now.h>
#include <LittleFS.h>
#include <Update.h>
#include "time.h"

// ------------------- КОНФИГУРАЦИЯ -------------------
#define HUB_ID 1
#define VERSION "3.0 S3"

// Настройки WiFi точки доступа
const char* AP_SSID = "SmartHomeHub-S3";
const char* AP_PASSWORD = "admin1234";
const IPAddress localIP(192, 168, 4, 1);
const IPAddress gateway(192, 168, 4, 1);
const IPAddress subnet(255, 255, 255, 0);

// Порт серверов
#define HTTP_PORT 80
#define WS_PORT 81

// Тайминги
#define WS_UPDATE_INTERVAL 2000    // WebSocket обновление (мс)
#define NODE_TIMEOUT 30000         // Таймаут узла (мс)
#define LOG_RETENTION 100          // Количество записей в логе

// ------------------- СТРУКТУРЫ ДАННЫХ -------------------
// ESP-NOW сообщение (совместимо с узлами)
typedef struct {
    char command[32];
    uint8_t sender_id;
    uint8_t target_id;
    uint32_t timestamp;
} espnow_message_t;

// Данные узла
typedef struct {
    uint8_t mac[6];
    uint8_t id;
    String type;           // "ESP8266", "ESP32-C3"
    String lastSeen;
    int rssi;
    bool online;
    
    // Данные сенсоров
    float temperature;
    float humidity;
    float pressure;
    float co2;
    float tvoc;
    float light;
    int chains[3];         // Состояние цепей 1-3
    
    // Состояние управляющих выходов
    bool relay1;
    bool relay2;
    bool led;
    
    // Системное
    uint32_t lastUpdate;
    uint32_t packetCount;
} node_data_t;

// Журнал событий
typedef struct {
    String time;
    String source;
    String message;
    String type;          // "info", "warning", "alert", "command"
} log_entry_t;

// ------------------- ГЛОБАЛЬНЫЕ ОБЪЕКТЫ -------------------
AsyncWebServer server(HTTP_PORT);
WebSocketsServer webSocket(WS_PORT);

// Хранилище данных
std::vector<node_data_t> nodes;
std::vector<log_entry_t> eventLog;
std::vector<espnow_message_t> commandQueue;

// MAC-адреса известных узлов (для примера)
uint8_t node1_mac[] = {0x9C, 0x9C, 0x1F, 0xC7, 0x2D, 0x94};
uint8_t node2_mac[] = {0x24, 0x6F, 0x28, 0x8A, 0x10, 0x3C};

// Флаги состояния
bool wifiActive = false;
bool espnowActive = false;
bool websocketActive = false;
unsigned long systemUptime = 0;

// JSON буферы
StaticJsonDocument<2048> wsDoc;
StaticJsonDocument<4096> apiDoc;

// ======================================================================
// ФУНКЦИИ ESP-NOW
// ======================================================================

// Инициализация ESP-NOW
void initESPNow() {
    WiFi.mode(WIFI_AP_STA);
    
    if (esp_now_init() != ESP_OK) {
        Serial.println("❌ ESP-NOW init failed");
        addLog("SYSTEM", "ESP-NOW initialization failed", "alert");
        return;
    }
    
    // Регистрация колбэков
    esp_now_register_recv_cb([](const uint8_t *mac, const uint8_t *data, int len) {
        onESPNowReceive(mac, data, len);
    });
    
    esp_now_register_send_cb([](const uint8_t *mac, esp_now_send_status_t status) {
        onESPNowSend(mac, status);
    });
    
    // Добавление известных узлов как пиров
    esp_now_peer_info_t peerInfo = {};
    peerInfo.channel = 1;
    peerInfo.encrypt = false;
    
    memcpy(peerInfo.peer_addr, node1_mac, 6);
    esp_now_add_peer(&peerInfo);
    
    memcpy(peerInfo.peer_addr, node2_mac, 6);
    esp_now_add_peer(&peerInfo);
    
    espnowActive = true;
    Serial.println("✅ ESP-NOW initialized");
    addLog("SYSTEM", "ESP-NOW initialized", "info");
}

// Обработка входящих ESP-NOW сообщений
void onESPNowReceive(const uint8_t *mac, const uint8_t *data, int len) {
    if (len < sizeof(espnow_message_t)) return;
    
    espnow_message_t msg;
    memcpy(&msg, data, sizeof(msg));
    
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    
    // Обновление данных узла
    updateNodeData(mac, msg);
    
    // Логирование
    char logMsg[128];
    snprintf(logMsg, sizeof(logMsg), "ESP-NOW from %s: %s (Node %d)",
             macStr, msg.command, msg.sender_id);
    addLog("ESP-NOW", logMsg, "info");
    
    // Рассылка через WebSocket
    sendWSNodeUpdate(mac, msg);
}

// Отправка команды узлу
bool sendNodeCommand(uint8_t targetId, const char* command) {
    espnow_message_t cmd;
    strncpy(cmd.command, command, sizeof(cmd.command)-1);
    cmd.sender_id = HUB_ID;
    cmd.target_id = targetId;
    cmd.timestamp = millis();
    
    // Поиск MAC адреса узла
    uint8_t* targetMac = findNodeMac(targetId);
    if (!targetMac) {
        Serial.printf("❌ Node %d not found\n", targetId);
        return false;
    }
    
    esp_err_t result = esp_now_send(targetMac, (uint8_t*)&cmd, sizeof(cmd));
    
    char logMsg[64];
    snprintf(logMsg, sizeof(logMsg), "CMD to Node %d: %s (%s)",
             targetId, command, result == ESP_OK ? "OK" : "FAIL");
    addLog("CONTROL", logMsg, result == ESP_OK ? "info" : "warning");
    
    return result == ESP_OK;
}

// ======================================================================
// УПРАВЛЕНИЕ УЗЛАМИ
// ======================================================================

// Обновление данных узла
void updateNodeData(const uint8_t* mac, const espnow_message_t& msg) {
    // Поиск существующего узла
    for (auto& node : nodes) {
        if (memcmp(node.mac, mac, 6) == 0) {
            node.lastSeen = getTimeString();
            node.lastUpdate = millis();
            node.online = true;
            node.packetCount++;
            
            // Парсинг подтверждений
            if (strstr(msg.command, "ACK_")) {
                handleNodeAck(&node, msg.command);
            }
            return;
        }
    }
    
    // Добавление нового узла
    node_data_t newNode;
    memcpy(newNode.mac, mac, 6);
    newNode.id = msg.sender_id;
    newNode.type = "Unknown";
    newNode.lastSeen = getTimeString();
    newNode.lastUpdate = millis();
    newNode.online = true;
    newNode.packetCount = 1;
    
    nodes.push_back(newNode);
    
    char logMsg[64];
    snprintf(logMsg, sizeof(logMsg), "New node detected: ID %d", msg.sender_id);
    addLog("NETWORK", logMsg, "info");
}

// Обработка подтверждений от узлов
void handleNodeAck(node_data_t* node, const char* ack) {
    if (strcmp(ack, "ACK_ON") == 0) node->led = true;
    else if (strcmp(ack, "ACK_OFF") == 0) node->led = false;
    else if (strcmp(ack, "ACK_RELAY1_ON") == 0) node->relay1 = true;
    else if (strcmp(ack, "ACK_RELAY1_OFF") == 0) node->relay1 = false;
    else if (strcmp(ack, "ACK_RELAY2_ON") == 0) node->relay2 = true;
    else if (strcmp(ack, "ACK_RELAY2_OFF") == 0) node->relay2 = false;
    
    // Рассылка обновления через WebSocket
    sendWSNodeList();
}

// ======================================================================
// WEB SERVER & WEB SOCKET
// ======================================================================

// Инициализация веб-сервера
void initWebServer() {
    // Инициализация LittleFS
    if (!LittleFS.begin()) {
        Serial.println("❌ LittleFS failed!");
        addLog("SYSTEM", "Filesystem mount failed", "alert");
        return;
    }
    
    // API эндпоинты
    // Получение списка узлов
    server.on("/api/nodes", HTTP_GET, [](AsyncWebServerRequest *request) {
        apiDoc.clear();
        JsonArray nodesArray = apiDoc.createNestedArray("nodes");
        
        for (const auto& node : nodes) {
            JsonObject nodeObj = nodesArray.createNestedObject();
            nodeObj["id"] = node.id;
            nodeObj["online"] = node.online;
            nodeObj["type"] = node.type;
            nodeObj["rssi"] = node.rssi;
            nodeObj["lastSeen"] = node.lastSeen;
            nodeObj["temperature"] = node.temperature;
            nodeObj["humidity"] = node.humidity;
        }
        
        String response;
        serializeJson(apiDoc, response);
        request->send(200, "application/json", response);
    });
    
    // Отправка команды узлу
    server.on("/api/command", HTTP_POST, [](AsyncWebServerRequest *request) {
        if (!request->hasParam("node", true) || !request->hasParam("cmd", true)) {
            request->send(400, "application/json", "{\"error\":\"Missing parameters\"}");
            return;
        }
        
        int nodeId = request->getParam("node", true)->value().toInt();
        String command = request->getParam("cmd", true)->value();
        
        bool success = sendNodeCommand(nodeId, command.c_str());
        
        apiDoc.clear();
        apiDoc["success"] = success;
        apiDoc["node"] = nodeId;
        apiDoc["command"] = command;
        
        String response;
        serializeJson(apiDoc, response);
        request->send(200, "application/json", response);
    });
    
    // Получение логов
    server.on("/api/logs", HTTP_GET, [](AsyncWebServerRequest *request) {
        apiDoc.clear();
        JsonArray logsArray = apiDoc.createNestedArray("logs");
        
        for (const auto& entry : eventLog) {
            JsonObject logObj = logsArray.createNestedObject();
            logObj["time"] = entry.time;
            logObj["source"] = entry.source;
            logObj["message"] = entry.message;
            logObj["type"] = entry.type;
        }
        
        String response;
        serializeJson(apiDoc, response);
        request->send(200, "application/json", response);
    });
    
    // Системная информация
    server.on("/api/system", HTTP_GET, [](AsyncWebServerRequest *request) {
        apiDoc.clear();
        apiDoc["version"] = VERSION;
        apiDoc["uptime"] = systemUptime;
        apiDoc["freeHeap"] = ESP.getFreeHeap();
        apiDoc["wifiClients"] = WiFi.softAPgetStationNum();
        apiDoc["nodesCount"] = nodes.size();
        
        String response;
        serializeJson(apiDoc, response);
        request->send(200, "application/json", response);
    });
    
    // Обновление прошивки (OTA)
    server.on("/update", HTTP_POST, [](AsyncWebServerRequest *request) {
        request->send(200, "text/plain", Update.hasError() ? "FAIL" : "OK");
        ESP.restart();
    }, [](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final) {
        if (!index) {
            Serial.printf("Update: %s\n", filename.c_str());
            if (!Update.begin(UPDATE_SIZE_UNKNOWN)) {
                Update.printError(Serial);
            }
        }
        
        if (Update.write(data, len) != len) {
            Update.printError(Serial);
        }
        
        if (final) {
            if (Update.end(true)) {
                Serial.printf("Update Success: %u bytes\n", index + len);
            } else {
                Update.printError(Serial);
            }
        }
    });
    
    // Статические файлы (веб-интерфейс)
    server.serveStatic("/", LittleFS, "/www/").setDefaultFile("index.html");
    
    // Обработчик 404
    server.onNotFound([](AsyncWebServerRequest *request) {
        if (request->method() == HTTP_OPTIONS) {
            request->send(200);
        } else {
            request->send(404, "text/plain", "Not Found");
        }
    });
    
    // CORS headers
    DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
    DefaultHeaders::Instance().addHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
    DefaultHeaders::Instance().addHeader("Access-Control-Allow-Headers", "Content-Type");
    
    server.begin();
    Serial.println("✅ HTTP server started");
}

// Инициализация WebSocket
void initWebSocket() {
    webSocket.begin();
    webSocket.onEvent([](uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
        switch(type) {
            case WStype_CONNECTED:
                Serial.printf("WS[%u] connected\n", num);
                sendWSInitialData(num);
                break;
                
            case WStype_DISCONNECTED:
                Serial.printf("WS[%u] disconnected\n", num);
                break;
                
            case WStype_TEXT:
                handleWSMessage(num, payload, length);
                break;
        }
    });
    
    websocketActive = true;
    Serial.println("✅ WebSocket server started");
}

// Отправка начальных данных при подключении WebSocket
void sendWSInitialData(uint8_t clientId) {
    wsDoc.clear();
    wsDoc["type"] = "init";
    wsDoc["hubId"] = HUB_ID;
    wsDoc["version"] = VERSION;
    
    JsonArray nodesArray = wsDoc.createNestedArray("nodes");
    for (const auto& node : nodes) {
        JsonObject nodeObj = nodesArray.createNestedObject();
        nodeObj["id"] = node.id;
        nodeObj["online"] = node.online;
        nodeObj["temperature"] = node.temperature;
        nodeObj["humidity"] = node.humidity;
    }
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.sendTXT(clientId, json);
}

// Обработка сообщений WebSocket
void handleWSMessage(uint8_t clientId, uint8_t *payload, size_t length) {
    StaticJsonDocument<256> doc;
    DeserializationError error = deserializeJson(doc, payload, length);
    
    if (error) {
        Serial.printf("WS JSON error: %s\n", error.c_str());
        return;
    }
    
    const char* action = doc["action"];
    if (!action) return;
    
    if (strcmp(action, "command") == 0) {
        uint8_t nodeId = doc["nodeId"];
        const char* command = doc["command"];
        
        if (nodeId && command) {
            sendNodeCommand(nodeId, command);
        }
    }
    else if (strcmp(action, "getLogs") == 0) {
        sendWSLogs(clientId);
    }
    else if (strcmp(action, "getSystem") == 0) {
        sendWSSystem(clientId);
    }
}

// ======================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ======================================================================

// Добавление записи в журнал
void addLog(const char* source, const char* message, const char* type) {
    if (eventLog.size() >= LOG_RETENTION) {
        eventLog.erase(eventLog.begin());
    }
    
    log_entry_t entry;
    entry.time = getTimeString();
    entry.source = source;
    entry.message = message;
    entry.type = type;
    
    eventLog.push_back(entry);
    
    // Рассылка через WebSocket
    sendWSLogUpdate(entry);
    
    Serial.printf("[%s] %s: %s\n", type, source, message);
}

// Получение строки времени
String getTimeString() {
    struct tm timeinfo;
    if(!getLocalTime(&timeinfo)){
        unsigned long m = millis();
        char buf[32];
        snprintf(buf, sizeof(buf), "%02lu:%02lu:%02lu", 
                 (m/3600000)%24, (m/60000)%60, (m/1000)%60);
        return String(buf);
    }
    
    char buf[32];
    strftime(buf, sizeof(buf), "%H:%M:%S", &timeinfo);
    return String(buf);
}

// WebSocket рассылки
void sendWSNodeUpdate(const uint8_t* mac, const espnow_message_t& msg) {
    wsDoc.clear();
    wsDoc["type"] = "nodeUpdate";
    wsDoc["nodeId"] = msg.sender_id;
    wsDoc["command"] = msg.command;
    wsDoc["timestamp"] = msg.timestamp;
    
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    wsDoc["mac"] = macStr;
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.broadcastTXT(json);
}

void sendWSNodeList() {
    wsDoc.clear();
    wsDoc["type"] = "nodeList";
    
    JsonArray nodesArray = wsDoc.createNestedArray("nodes");
    for (const auto& node : nodes) {
        JsonObject nodeObj = nodesArray.createNestedObject();
        nodeObj["id"] = node.id;
        nodeObj["online"] = node.online;
        nodeObj["type"] = node.type;
        nodeObj["rssi"] = node.rssi;
        nodeObj["lastSeen"] = node.lastSeen;
        nodeObj["temperature"] = node.temperature;
        nodeObj["humidity"] = node.humidity;
        nodeObj["relay1"] = node.relay1;
        nodeObj["relay2"] = node.relay2;
        nodeObj["led"] = node.led;
    }
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.broadcastTXT(json);
}

void sendWSLogs(uint8_t clientId) {
    wsDoc.clear();
    wsDoc["type"] = "logBatch";
    
    JsonArray logsArray = wsDoc.createNestedArray("logs");
    for (const auto& entry : eventLog) {
        JsonObject logObj = logsArray.createNestedObject();
        logObj["time"] = entry.time;
        logObj["source"] = entry.source;
        logObj["message"] = entry.message;
        logObj["type"] = entry.type;
    }
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.sendTXT(clientId, json);
}

void sendWSLogUpdate(const log_entry_t& entry) {
    wsDoc.clear();
    wsDoc["type"] = "logUpdate";
    wsDoc["time"] = entry.time;
    wsDoc["source"] = entry.source;
    wsDoc["message"] = entry.message;
    wsDoc["logType"] = entry.type;
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.broadcastTXT(json);
}

void sendWSSystem(uint8_t clientId) {
    wsDoc.clear();
    wsDoc["type"] = "system";
    wsDoc["uptime"] = systemUptime;
    wsDoc["freeHeap"] = ESP.getFreeHeap();
    wsDoc["wifiClients"] = WiFi.softAPgetStationNum();
    wsDoc["nodesOnline"] = countOnlineNodes();
    wsDoc["espNowActive"] = espnowActive;
    
    String json;
    serializeJson(wsDoc, json);
    webSocket.sendTXT(clientId, json);
}

// Подсчет онлайн узлов
int countOnlineNodes() {
    int count = 0;
    for (const auto& node : nodes) {
        if (node.online && (millis() - node.lastUpdate < NODE_TIMEOUT)) {
            count++;
        } else {
            node.online = false;
        }
    }
    return count;
}

// Поиск MAC адреса узла по ID
uint8_t* findNodeMac(uint8_t nodeId) {
    for (auto& node : nodes) {
        if (node.id == nodeId) {
            return node.mac;
        }
    }
    return nullptr;
}

// ======================================================================
// SETUP & LOOP
// ======================================================================

void setup() {
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("\n========================================");
    Serial.println("   ESP32-S3 SMART HOME HUB ULTIMATE");
    Serial.printf("   Version: %s\n", VERSION);
    Serial.println("========================================\n");
    
    // Настройка WiFi точки доступа
    WiFi.softAP(AP_SSID, AP_PASSWORD);
    WiFi.softAPConfig(localIP, gateway, subnet);
    delay(100);
    
    Serial.println("✅ WiFi Access Point started");
    Serial.printf("   SSID: %s\n", AP_SSID);
    Serial.printf("   IP: %s\n", WiFi.softAPIP().toString().c_str());
    
    // Инициализация подсистем
    initESPNow();
    initWebSocket();
    initWebServer();
    
    // Добавление стартовых записей в лог
    addLog("SYSTEM", "Hub initialization complete", "info");
    addLog("SYSTEM", "Waiting for nodes...", "info");
    
    Serial.println("\n✅ Hub ready!");
    Serial.println("   Web Interface: http://192.168.4.1");
    Serial.println("   WebSocket: ws://192.168.4.1:81");
    Serial.println("   API: http://192.168.4.1/api/*");
}

void loop() {
    webSocket.loop();
    systemUptime = millis() / 1000;
    
    // Периодическая проверка узлов
    static unsigned long lastNodeCheck = 0;
    if (millis() - lastNodeCheck > 5000) {
        lastNodeCheck = millis();
        
        // Отправка системной информации по WebSocket
        if (websocketActive && webSocket.connectedClients() > 0) {
            sendWSSystem(0); // Отправляем первому клиенту (broadcast не всегда работает)
            
            // Периодическая отправка списка узлов
            static unsigned long lastNodeBroadcast = 0;
            if (millis() - lastNodeBroadcast > 10000) {
                lastNodeBroadcast = millis();
                sendWSNodeList();
            }
        }
        
        // Проверка таймаута узлов
        for (auto& node : nodes) {
            if (node.online && (millis() - node.lastUpdate > NODE_TIMEOUT)) {
                node.online = false;
                
                char logMsg[64];
                snprintf(logMsg, sizeof(logMsg), "Node %d timeout", node.id);
                addLog("NETWORK", logMsg, "warning");
                
                sendWSNodeList(); // Уведомление веб-интерфейса
            }
        }
    }
    
    delay(10);
}
