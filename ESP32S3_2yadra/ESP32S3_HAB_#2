// ======================================================================
// ESP32-S3 SMART HUB (FINAL WORKING VERSION)
// –í–µ—Ä—Å–∏—è: 2.0 - FreeRTOS + AsyncWebServer + ESP-NOW + WebSocket
// –ê–≤—Ç–æ—Ä: Optimized from UmniyDom_KAV project
// –î–∞—Ç–∞: 2024
// ======================================================================

// ===================== –ë–ò–ë–õ–ò–û–¢–ï–ö–ò =====================
#include <WiFi.h>
#include <esp_now.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>

// ===================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====================
#define DEBUG_MODE true
#define MAX_NODES 10
#define NODE_TIMEOUT_MS 30000  // 30 —Å–µ–∫—É–Ω–¥ –¥–ª—è –æ—Ñ—Ñ–ª–∞–π–Ω–∞
#define WS_RECONNECT_INTERVAL 5000

// ===================== –°–¢–†–£–ö–¢–£–†–´ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò =====================
struct PreconfiguredNode {
    uint8_t mac[6];
    uint32_t nodeId;
    String name;
    uint8_t nodeType;  // 2=PIR, 3=RELAY, 4=RGB, 5=LIGHT_SENSOR
};

// –í–ê–®–ò –£–ó–õ–´
PreconfiguredNode knownNodes[] = {
    {{0x88, 0x56, 0xA6, 0x7C, 0xF2, 0xA8}, 2, "Uzel_2", 2},  // PIR + —Ä–µ–ª–µ
    {{0x88, 0x56, 0xA6, 0x7D, 0x09, 0x64}, 3, "Uzel_3", 3},  // –†–µ–ª–µ –º–æ–¥—É–ª—å
    {{0x10, 0x00, 0x3B, 0xB1, 0xA6, 0x9C}, 4, "Uzel_4", 4},  // RGB —Å–≤–µ—Ç
    {{0xAC, 0xEB, 0xE6, 0x49, 0x10, 0x28}, 5, "Uzel_5", 5}   // –î–∞—Ç—á–∏–∫ —Å–≤–µ—Ç–∞
};

const int KNOWN_NODES_COUNT = sizeof(knownNodes) / sizeof(knownNodes[0]);

// ===================== –°–¢–†–£–ö–¢–£–†–ê –î–ê–ù–ù–´–• –£–ó–õ–ê =====================
struct NodeData {
    // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    uint8_t mac[6] = {0};
    uint32_t nodeId = 0;
    String name = "Unknown";
    uint8_t nodeType = 0;
    String ip = "0.0.0.0";
    
    // –°—Ç–∞—Ç—É—Å
    bool preconfigured = false;
    bool espNowRegistered = false;
    bool online = false;
    bool alarmFlag = false;
    
    // –î–∞–Ω–Ω—ã–µ –¥–∞—Ç—á–∏–∫–æ–≤
    float value1 = 0.0;
    float value2 = 0.0;
    uint8_t relay1_state = 0;
    uint8_t relay2_state = 0;
    uint8_t status = 0;
    int rssi = 0;
    int freeHeap = 0;
    
    // –í—Ä–µ–º—è
    unsigned long lastSeen = 0;
    unsigned long lastCommandTime = 0;
    
    // –ö–æ–º–∞–Ω–¥—ã
    String lastCommand = "";
    String lastAck = "";
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã—Ö–æ–¥–æ–≤ (–¥–ª—è –≤–µ–±–∞)
    bool ledState = false;
    bool relay1State = false;
    bool relay2State = false;
};

// ===================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï =====================
NodeData nodes[MAX_NODES];
int nodeCount = 0;
SemaphoreHandle_t xNodesSemaphore;

// –°–µ—Ç—å
const char* AP_SSID = "ESP32-S3-Hub";
const char* AP_PASSWORD = "smart12345678";

// –í–µ–±-—Å–µ—Ä–≤–µ—Ä
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

// ESP-NOW —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
#pragma pack(push, 1)
struct EspNowMessage {
    uint32_t sender_id;
    uint8_t command_type;  // 1=–¥–∞–Ω–Ω—ã–µ, 2=–∫–æ–º–∞–Ω–¥–∞, 3=–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    float value1;
    float value2;
    uint8_t relay1_state;
    uint8_t relay2_state;
    uint8_t status;
    uint32_t timestamp;
};
#pragma pack(pop)

// ===================== –ü–†–û–¢–û–¢–ò–ü–´ –§–£–ù–ö–¶–ò–ô =====================
// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
void setupWiFiAP();
void setupESP_NOW();
void registerPreconfiguredNodes();
void setupAsyncWebServer();

// –†–∞–±–æ—Ç–∞ —Å —É–∑–ª–∞–º–∏
int findNodeByMac(const uint8_t* mac);
int findNodeById(uint32_t nodeId);
void updateNodeData(int index, const EspNowMessage* msg, int rssi);
void checkNodeTimeouts();

// –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
bool sendEspNowCommand(uint32_t nodeId, uint8_t commandType, float val1 = 0, float val2 = 0);
void sendWebSocketUpdate(int nodeIndex);
void broadcastSystemStatus();

// JSON
String getNodesJSON();
String getNodeJSON(int index);

// WebSocket
void onWebSocketEvent(AsyncWebSocket* server, AsyncWebSocketClient* client, 
                     AwsEventType type, void* arg, uint8_t* data, size_t len);

// ESP-NOW –∫–æ–ª–±—ç–∫–∏
void OnDataSent(const uint8_t* mac_addr, esp_now_send_status_t status);
void OnDataRecv(const uint8_t* mac_addr, const uint8_t* incomingData, int len);

// FreeRTOS –∑–∞–¥–∞—á–∏
void Task_WebServer(void* pvParameters);
void Task_ESPNowLogic(void* pvParameters);

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ
void printNodeInfo(int index);
String macToString(const uint8_t* mac);

// ===================== HTML –°–¢–†–ê–ù–ò–¶–ê =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32-S3 Smart Hub</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Arial, sans-serif; }
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { background: rgba(255,255,255,0.95); padding: 25px; border-radius: 15px; margin-bottom: 25px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
        h1 { color: #2d3748; font-size: 2.2em; margin-bottom: 10px; }
        .status-bar { display: flex; gap: 25px; font-weight: 600; font-size: 1.1em; }
        .status-online { color: #38a169; }
        .status-offline { color: #e53e3e; }
        .dashboard { display: flex; flex-direction: column; gap: 30px; }
        .section { background: rgba(255,255,255,0.95); padding: 25px; border-radius: 15px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
        .section h2 { margin-bottom: 20px; color: #2d3748; border-bottom: 3px solid #667eea; padding-bottom: 12px; font-size: 1.8em; }
        .nodes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 25px; margin-top: 20px; }
        .node-card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); transition: transform 0.3s, box-shadow 0.3s; border-left: 5px solid; }
        .node-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
        .node-type-2 { border-color: #4299e1; }
        .node-type-3 { border-color: #ed8936; }
        .node-type-4 { border-color: #9f7aea; }
        .node-type-5 { border-color: #48bb78; }
        .node-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .node-id { font-size: 1.4em; font-weight: 700; color: #2d3748; }
        .node-type { font-size: 0.9em; padding: 5px 15px; border-radius: 20px; color: white; font-weight: 600; }
        .type-pir { background: #4299e1; }
        .type-relay { background: #ed8936; }
        .type-rgb { background: #9f7aea; }
        .type-light { background: #48bb78; }
        .node-data { margin: 15px 0; font-size: 1.1em; }
        .data-row { display: flex; justify-content: space-between; margin: 8px 0; padding: 8px 0; border-bottom: 1px solid #e2e8f0; }
        .data-label { color: #718096; }
        .data-value { font-weight: 600; color: #2d3748; }
        .relay-control { display: flex; gap: 15px; margin-top: 20px; }
        .btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s; font-size: 1em; }
        .btn-on { background: #48bb78; color: white; }
        .btn-on:hover { background: #38a169; }
        .btn-off { background: #f56565; color: white; }
        .btn-off:hover { background: #e53e3e; }
        .btn-toggle { background: #667eea; color: white; }
        .btn-toggle:hover { background: #5a67d8; }
        .node-footer { margin-top: 15px; padding-top: 15px; border-top: 1px solid #e2e8f0; display: flex; justify-content: space-between; font-size: 0.9em; }
        .online-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .dot-online { background: #48bb78; }
        .dot-offline { background: #e53e3e; }
        .last-seen { color: #a0aec0; }
        .connection-status { position: fixed; bottom: 20px; right: 20px; padding: 15px 25px; border-radius: 10px; background: rgba(255,255,255,0.9); box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-weight: 600; }
        .connected { border-left: 5px solid #48bb78; }
        .disconnected { border-left: 5px solid #f56565; }
        @media (max-width: 768px) { .nodes-grid { grid-template-columns: 1fr; } .container { padding: 10px; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üè† ESP32-S3 Smart Hub</h1>
            <div class="status-bar">
                <span id="wifi-status" class="status-online">WiFi: AP Active</span>
                <span id="nodes-count">–£–∑–ª–æ–≤: 0/4</span>
                <span id="ws-status" class="status-offline">WebSocket: –û—Ç–∫–ª—é—á–µ–Ω</span>
            </div>
        </header>
        
        <div class="dashboard">
            <section class="section">
                <h2>üì° –ë–µ—Å–ø—Ä–æ–≤–æ–¥–Ω—ã–µ —É–∑–ª—ã ESP-NOW</h2>
                <div class="nodes-grid" id="nodes-container">
                    <!-- –£–∑–ª—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                </div>
            </section>
        </div>
        
        <div id="connection-status" class="connection-status disconnected">
            üîå –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è WebSocket...
        </div>
    </div>

    <script>
        let ws;
        const nodes = {};
        const typeNames = {2:'PIR –¥–∞—Ç—á–∏–∫',3:'–†–µ–ª–µ –º–æ–¥—É–ª—å',4:'RGB —Å–≤–µ—Ç',5:'–î–∞—Ç—á–∏–∫ —Å–≤–µ—Ç–∞'};
        const typeColors = {2:'type-pir',3:'type-relay',4:'type-rgb',5:'type-light'};
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || '192.168.4.1';
            ws = new WebSocket(`${protocol}//${host}:80/ws`);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
                updateStatus('connected', '‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Ö–∞–±—É');
                document.getElementById('ws-status').textContent = "WebSocket: –ü–æ–¥–∫–ª—é—á–µ–Ω";
                document.getElementById('ws-status').className = "status-online";
                ws.send(JSON.stringify({type: 'get_nodes'}));
            };
            
            ws.onclose = () => {
                console.log('‚ùå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω');
                updateStatus('disconnected', 'üîå –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                document.getElementById('ws-status').textContent = "WebSocket: –û—Ç–∫–ª—é—á–µ–Ω";
                document.getElementById('ws-status').className = "status-offline";
                setTimeout(connectWebSocket, 2000);
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch(e) {
                    console.error('–û—à–∏–±–∫–∞ JSON:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket –æ—à–∏–±–∫–∞:', error);
            };
        }
        
        function updateStatus(status, text) {
            const elem = document.getElementById('connection-status');
            elem.className = `connection-status ${status}`;
            elem.innerHTML = text;
        }
        
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'nodes_list':
                    updateNodesList(data.nodes);
                    break;
                case 'node_update':
                    updateNodeCard(data.node);
                    break;
                case 'node_offline':
                    setNodeOffline(data.nodeId);
                    break;
                case 'system_status':
                    updateSystemStatus(data);
                    break;
            }
        }
        
        function updateNodesList(nodesList) {
            const container = document.getElementById('nodes-container');
            container.innerHTML = '';
            document.getElementById('nodes-count').textContent = `–£–∑–ª–æ–≤: ${nodesList.length}/4`;
            
            nodesList.forEach(node => {
                nodes[node.nodeId] = node;
                container.appendChild(createNodeCard(node));
            });
        }
        
        function createNodeCard(node) {
            const div = document.createElement('div');
            div.className = `node-card node-type-${node.nodeType}`;
            div.id = `node-${node.nodeId}`;
            
            let content = `
                <div class="node-header">
                    <div class="node-id">${node.name}</div>
                    <span class="node-type ${typeColors[node.nodeType]}">${typeNames[node.nodeType]}</span>
                </div>
                <div class="node-data">
                    <div class="data-row">
                        <span class="data-label">–°—Ç–∞—Ç—É—Å:</span>
                        <span class="data-value">${node.online ? 'Online' : 'Offline'}</span>
                    </div>`;
            
            // –î–∞–Ω–Ω—ã–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–∑–ª–∞
            if(node.nodeType === 2) { // PIR
                content += `
                    <div class="data-row">
                        <span class="data-label">–î–≤–∏–∂–µ–Ω–∏–µ:</span>
                        <span class="data-value">${node.value1 == 1 ? '–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ' : '–ù–µ—Ç'}</span>
                    </div>`;
            } else if(node.nodeType === 3) { // –†–µ–ª–µ
                content += `
                    <div class="data-row">
                        <span class="data-label">–†–µ–ª–µ 1:</span>
                        <span class="data-value">${node.relay1_state ? '–í–ö–õ' : '–í–´–ö–õ'}</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">–†–µ–ª–µ 2:</span>
                        <span class="data-value">${node.relay2_state ? '–í–ö–õ' : '–í–´–ö–õ'}</span>
                    </div>`;
            } else if(node.nodeType === 4) { // RGB
                content += `
                    <div class="data-row">
                        <span class="data-label">RGB —Å—Ç–∞—Ç—É—Å:</span>
                        <span class="data-value">${node.value1 ? '–ê–∫—Ç–∏–≤–µ–Ω' : '–í—ã–∫–ª—é—á–µ–Ω'}</span>
                    </div>`;
            } else if(node.nodeType === 5) { // –°–≤–µ—Ç
                content += `
                    <div class="data-row">
                        <span class="data-label">–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å:</span>
                        <span class="data-value">${node.value1 ? node.value1.toFixed(1) + '%' : '–ù/–î'}</span>
                    </div>`;
            }
            
            content += `
                </div>`;
            
            // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è —Ä–µ–ª–µ
            if(node.nodeType === 3) {
                content += `
                <div class="relay-control">
                    <button class="btn btn-toggle" onclick="sendCommand(${node.nodeId}, 'toggle', 1)">–ü–µ—Ä–µ–∫–ª. 1</button>
                    <button class="btn btn-on" onclick="sendCommand(${node.nodeId}, 'on', 1)">–í–ö–õ 1</button>
                    <button class="btn btn-off" onclick="sendCommand(${node.nodeId}, 'off', 1)">–í–´–ö–õ 1</button>
                </div>
                <div class="relay-control">
                    <button class="btn btn-toggle" onclick="sendCommand(${node.nodeId}, 'toggle', 2)">–ü–µ—Ä–µ–∫–ª. 2</button>
                    <button class="btn btn-on" onclick="sendCommand(${node.nodeId}, 'on', 2)">–í–ö–õ 2</button>
                    <button class="btn btn-off" onclick="sendCommand(${node.nodeId}, 'off', 2)">–í–´–ö–õ 2</button>
                </div>`;
            }
            
            content += `
                <div class="node-footer">
                    <div>
                        <span class="online-dot ${node.online ? 'dot-online' : 'dot-offline'}"></span>
                        ${node.online ? 'Online' : 'Offline'}
                    </div>
                    <div class="last-seen">
                        RSSI: ${node.rssi} dBm
                    </div>
                </div>`;
            
            div.innerHTML = content;
            return div;
        }
        
        function updateNodeCard(node) {
            if(nodes[node.nodeId]) {
                nodes[node.nodeId] = {...nodes[node.nodeId], ...node};
                const card = document.getElementById(`node-${node.nodeId}`);
                if(card) {
                    card.replaceWith(createNodeCard(nodes[node.nodeId]));
                }
            }
        }
        
        function setNodeOffline(nodeId) {
            if(nodes[nodeId]) {
                nodes[nodeId].online = false;
                const card = document.getElementById(`node-${nodeId}`);
                if(card) {
                    const dot = card.querySelector('.online-dot');
                    if(dot) dot.className = 'online-dot dot-offline';
                    const statusText = card.querySelector('.node-footer div:first-child');
                    if(statusText) statusText.innerHTML = `<span class="online-dot dot-offline"></span>Offline`;
                }
            }
        }
        
        function updateSystemStatus(data) {
            document.getElementById('wifi-status').textContent = `WiFi: ${data.wifi_connected ? 'Active' : 'Down'}`;
            document.getElementById('wifi-status').className = data.wifi_connected ? "status-online" : "status-offline";
        }
        
        function sendCommand(nodeId, command, relayNum = 1) {
            if(ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'send_command',
                    nodeId: nodeId,
                    command: command,
                    relayNum: relayNum
                }));
            }
        }
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', connectWebSocket);
    </script>
</body>
</html>
)rawliteral";

// ===================== –û–°–ù–û–í–ù–û–ô SETUP =====================
void setup() {
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("\n==================================================");
    Serial.println("       ESP32-S3 SMART HUB (FINAL VERSION)");
    Serial.println("==================================================");
    Serial.println("–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: FreeRTOS + AsyncWebServer + ESP-NOW");
    Serial.println("–í–µ—Ä—Å–∏—è: 2.0");
    Serial.println("–î–∞—Ç–∞: 2024");
    Serial.println("==================================================");
    
    // 1. –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–º–∞—Ñ–æ—Ä–∞ –¥–ª—è –∑–∞—â–∏—Ç—ã –¥–∞–Ω–Ω—ã—Ö
    xNodesSemaphore = xSemaphoreCreateMutex();
    if (xNodesSemaphore == NULL) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞!");
        while (1) delay(1000);
    }
    
    // 2. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Wi-Fi —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞
    setupWiFiAP();
    
    // 3. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ESP-NOW
    setupESP_NOW();
    
    // 4. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤
    registerPreconfiguredNodes();
    
    // 5. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
    setupAsyncWebServer();
    
    // 6. –°–æ–∑–¥–∞–Ω–∏–µ FreeRTOS –∑–∞–¥–∞—á
    xTaskCreatePinnedToCore(
        Task_WebServer,
        "WebServer_Task",
        8192,
        NULL,
        1,
        NULL,
        0  // Core 0
    );
    
    xTaskCreatePinnedToCore(
        Task_ESPNowLogic,
        "ESPNow_Task",
        8192,
        NULL,
        2,  // –ë–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
        NULL,
        1  // Core 1
    );
    
    Serial.println("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ!");
    Serial.println("   - Wi-Fi AP: " + String(AP_SSID));
    Serial.println("   - IP –∞–¥—Ä–µ—Å: " + WiFi.softAPIP().toString());
    Serial.println("   - –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ —É–∑–ª–æ–≤: " + String(nodeCount));
    Serial.println("==================================================\n");
}

// ===================== –û–°–ù–û–í–ù–û–ô LOOP =====================
void loop() {
    // –û—Å–Ω–æ–≤–Ω–æ–π loop –ø—É—Å—Ç–æ–π - –≤—Å—è –ª–æ–≥–∏–∫–∞ –≤ –∑–∞–¥–∞—á–∞—Ö FreeRTOS
    delay(1000);
}

// ===================== –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –§–£–ù–ö–¶–ò–ô =====================

// 1. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Wi-Fi —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞
void setupWiFiAP() {
    WiFi.mode(WIFI_AP);
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è AP
    if (!WiFi.softAP(AP_SSID, AP_PASSWORD, 1, 0, 4)) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞!");
        while (1) delay(1000);
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ IP (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    // IPAddress local_ip(192,168,4,1);
    // IPAddress gateway(192,168,4,1);
    // IPAddress subnet(255,255,255,0);
    // WiFi.softAPConfig(local_ip, gateway, subnet);
    
    Serial.println("‚úÖ –¢–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —Å–æ–∑–¥–∞–Ω–∞:");
    Serial.println("   SSID: " + String(AP_SSID));
    Serial.println("   IP: " + WiFi.softAPIP().toString());
    Serial.println("   MAC: " + WiFi.softAPmacAddress());
}

// 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ESP-NOW
void setupESP_NOW() {
    if (esp_now_init() != ESP_OK) {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ESP-NOW!");
        while (1) delay(1000);
    }
    
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—â–Ω–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥–∞—á–∏ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —ç–Ω–µ—Ä–≥–∏–∏)
    WiFi.setTxPower(WIFI_POWER_8_5dBm);
    
    Serial.println("‚úÖ ESP-NOW –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
}

// 3. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤
void registerPreconfiguredNodes() {
    Serial.println("\n=== –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –£–ó–õ–û–í ===");
    
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < KNOWN_NODES_COUNT; i++) {
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –º–∞—Å—Å–∏–≤ nodes
            int idx = nodeCount;
            if (idx >= MAX_NODES) {
                Serial.println("‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —É–∑–ª–æ–≤!");
                break;
            }
            
            // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            memcpy(nodes[idx].mac, knownNodes[i].mac, 6);
            nodes[idx].nodeId = knownNodes[i].nodeId;
            nodes[idx].name = knownNodes[i].name;
            nodes[idx].nodeType = knownNodes[i].nodeType;
            nodes[idx].preconfigured = true;
            nodes[idx].online = false;
            nodes[idx].lastSeen = 0;
            
            // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ ESP-NOW
            esp_now_peer_info_t peerInfo;
            memset(&peerInfo, 0, sizeof(peerInfo));
            memcpy(peerInfo.peer_addr, knownNodes[i].mac, 6);
            peerInfo.channel = 1;
            peerInfo.encrypt = false;
            
            if (esp_now_add_peer(&peerInfo) == ESP_OK) {
                nodes[idx].espNowRegistered = true;
                Serial.print("‚úÖ ");
            } else {
                nodes[idx].espNowRegistered = false;
                Serial.print("‚ö†Ô∏è ");
            }
            
            Serial.print("–£–∑–µ–ª " + nodes[idx].name + " (ID:" + String(nodes[idx].nodeId) + 
                        ", MAC:" + macToString(nodes[idx].mac) + ")");
            
            if (nodes[idx].espNowRegistered) {
                Serial.println(" - –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ ESP-NOW");
            } else {
                Serial.println(" - –æ—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ ESP-NOW");
            }
            
            nodeCount++;
        }
        xSemaphoreGive(xNodesSemaphore);
    }
    
    Serial.println("–í—Å–µ–≥–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ: " + String(nodeCount) + " —É–∑–ª–æ–≤\n");
}

// 4. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
void setupAsyncWebServer() {
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ WebSocket
    ws.onEvent(onWebSocketEvent);
    server.addHandler(&ws);
    
    // –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
    server.on("/", HTTP_GET, [](AsyncWebServerRequest* request) {
        request->send_P(200, "text/html", index_html);
    });
    
    // API: –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤ –≤ JSON
    server.on("/api/nodes", HTTP_GET, [](AsyncWebServerRequest* request) {
        if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
            String jsonResponse = getNodesJSON();
            xSemaphoreGive(xNodesSemaphore);
            request->send(200, "application/json", jsonResponse);
        } else {
            request->send(503, "application/json", "{\"error\":\"service_unavailable\"}");
        }
    });
    
    // API: –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —É–∑–ª–∞
    server.on("/api/node", HTTP_GET, [](AsyncWebServerRequest* request) {
        if (request->hasParam("id")) {
            int nodeId = request->getParam("id")->value().toInt();
            int index = findNodeById(nodeId);
            
            if (index != -1 && xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                String jsonResponse = getNodeJSON(index);
                xSemaphoreGive(xNodesSemaphore);
                request->send(200, "application/json", jsonResponse);
            } else {
                request->send(404, "application/json", "{\"error\":\"node_not_found\"}");
            }
        } else {
            request->send(400, "application/json", "{\"error\":\"missing_id\"}");
        }
    });
    
    // API: –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É —É–∑–ª—É
    server.on("/api/command", HTTP_POST, [](AsyncWebServerRequest* request) {
        if (request->hasParam("nodeId", true) && request->hasParam("command", true)) {
            int nodeId = request->getParam("nodeId", true)->value().toInt();
            String command = request->getParam("command", true)->value();
            
            bool success = false;
            
            if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                int index = findNodeById(nodeId);
                if (index != -1) {
                    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–º–∞–Ω–¥—ã
                    uint8_t cmdType = 2; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - –∫–æ–º–∞–Ω–¥–∞
                    float val1 = 0, val2 = 0;
                    
                    if (command == "toggle" && request->hasParam("relayNum", true)) {
                        int relayNum = request->getParam("relayNum", true)->value().toInt();
                        val1 = (relayNum == 1) ? 1.0 : 2.0;
                        cmdType = 3; // –ö–æ–º–∞–Ω–¥–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
                    } else if (command == "on" && request->hasParam("relayNum", true)) {
                        int relayNum = request->getParam("relayNum", true)->value().toInt();
                        val1 = (relayNum == 1) ? 1.0 : 2.0;
                        cmdType = 4; // –ö–æ–º–∞–Ω–¥–∞ –≤–∫–ª—é—á–µ–Ω–∏—è
                    } else if (command == "off" && request->hasParam("relayNum", true)) {
                        int relayNum = request->getParam("relayNum", true)->value().toInt();
                        val1 = (relayNum == 1) ? 1.0 : 2.0;
                        cmdType = 5; // –ö–æ–º–∞–Ω–¥–∞ –≤—ã–∫–ª—é—á–µ–Ω–∏—è
                    }
                    
                    success = sendEspNowCommand(nodeId, cmdType, val1, val2);
                    
                    if (success) {
                        nodes[index].lastCommand = command;
                        nodes[index].lastCommandTime = millis();
                        Serial.println("–ö–æ–º–∞–Ω–¥–∞ \"" + command + "\" –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —É–∑–ª—É " + nodes[index].name);
                    }
                }
                xSemaphoreGive(xNodesSemaphore);
            }
            
            if (success) {
                request->send(200, "application/json", "{\"status\":\"ok\"}");
            } else {
                request->send(404, "application/json", "{\"error\":\"command_failed\"}");
            }
        } else {
            request->send(400, "application/json", "{\"error\":\"missing_params\"}");
        }
    });
    
    // –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
    server.begin();
    Serial.println("‚úÖ AsyncWebServer –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 80");
}

// 5. WebSocket –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
void onWebSocketEvent(AsyncWebSocket* server, AsyncWebSocketClient* client,
                     AwsEventType type, void* arg, uint8_t* data, size_t len) {
    switch (type) {
        case WS_EVT_CONNECT:
            Serial.println("WebSocket –∫–ª–∏–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω: #" + String(client->id()));
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            broadcastSystemStatus();
            break;
            
        case WS_EVT_DISCONNECT:
            Serial.println("WebSocket –∫–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–µ–Ω: #" + String(client->id()));
            break;
            
        case WS_EVT_DATA: {
            AwsFrameInfo* info = (AwsFrameInfo*)arg;
            if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
                data[len] = 0; // Null-terminate
                String message = (char*)data;
                
                // –ü–∞—Ä—Å–∏–Ω–≥ JSON
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, message);
                if (error) {
                    Serial.println("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ WebSocket JSON: " + String(error.c_str()));
                    return;
                }
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã
                String msgType = doc["type"] | "";
                
                if (msgType == "get_nodes") {
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ —É–∑–ª–æ–≤
                    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                        String jsonResponse = getNodesJSON();
                        xSemaphoreGive(xNodesSemaphore);
                        client->text(jsonResponse);
                    }
                } else if (msgType == "send_command") {
                    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã —É–∑–ª—É
                    uint32_t nodeId = doc["nodeId"] | 0;
                    String command = doc["command"] | "";
                    int relayNum = doc["relayNum"] | 1;
                    
                    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                        int index = findNodeById(nodeId);
                        if (index != -1) {
                            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–º–∞–Ω–¥—ã ESP-NOW
                            uint8_t cmdType = 2;
                            float val1 = (relayNum == 1) ? 1.0 : 2.0;
                            float val2 = 0;
                            
                            if (command == "toggle") cmdType = 3;
                            else if (command == "on") cmdType = 4;
                            else if (command == "off") cmdType = 5;
                            
                            bool success = sendEspNowCommand(nodeId, cmdType, val1, val2);
                            
                            if (success) {
                                nodes[index].lastCommand = command + "_relay" + String(relayNum);
                                nodes[index].lastCommandTime = millis();
                                
                                JsonDocument resp;
                                resp["type"] = "command_ack";
                                resp["nodeId"] = nodeId;
                                resp["command"] = command;
                                resp["status"] = "sent";
                                
                                String response;
                                serializeJson(resp, response);
                                client->text(response);
                            }
                        }
                        xSemaphoreGive(xNodesSemaphore);
                    }
                }
            }
            break;
        }
        
        case WS_EVT_ERROR:
            Serial.println("WebSocket –æ—à–∏–±–∫–∞");
            break;
            
        case WS_EVT_PONG:
            break;
    }
}

// 6. –ö–æ–ª–±—ç–∫–∏ ESP-NOW
void OnDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac_addr[0], mac_addr[1], mac_addr[2],
             mac_addr[3], mac_addr[4], mac_addr[5]);
    
    if (status == ESP_NOW_SEND_SUCCESS) {
        Serial.print("‚úÖ –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ ");
    } else {
        Serial.print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞ ");
    }
    Serial.println(macStr);
}

void OnDataRecv(const uint8_t* mac_addr, const uint8_t* incomingData, int len) {
    if (len != sizeof(EspNowMessage)) {
        Serial.println("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞ ESP-NOW: " + String(len) + " –±–∞–π—Ç");
        return;
    }
    
    EspNowMessage msg;
    memcpy(&msg, incomingData, sizeof(msg));
    
    // –ü–æ–∏—Å–∫ —É–∑–ª–∞ –ø–æ MAC
    int index = findNodeByMac(mac_addr);
    
    if (index == -1) {
        // –ù–æ–≤—ã–π —É–∑–µ–ª - –ø–æ–ø—ã—Ç–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        Serial.print("‚ö†Ô∏è –ù–æ–≤—ã–π —É–∑–µ–ª —Å MAC: ");
        Serial.println(macToString(mac_addr));
        
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–¥–µ—Å—å
        return;
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        updateNodeData(index, &msg, WiFi.RSSI());
        xSemaphoreGive(xNodesSemaphore);
    }
}

// 7. –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å —É–∑–ª–∞–º–∏
int findNodeByMac(const uint8_t* mac) {
    for (int i = 0; i < nodeCount; i++) {
        if (memcmp(nodes[i].mac, mac, 6) == 0) {
            return i;
        }
    }
    return -1;
}

int findNodeById(uint32_t nodeId) {
    for (int i = 0; i < nodeCount; i++) {
        if (nodes[i].nodeId == nodeId) {
            return i;
        }
    }
    return -1;
}

void updateNodeData(int index, const EspNowMessage* msg, int rssi) {
    if (index < 0 || index >= nodeCount) return;
    
    NodeData* node = &nodes[index];
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    node->value1 = msg->value1;
    node->value2 = msg->value2;
    node->relay1_state = msg->relay1_state;
    node->relay2_state = msg->relay2_state;
    node->status = msg->status;
    node->rssi = rssi;
    node->freeHeap = ESP.getFreeHeap();
    node->lastSeen = millis();
    node->online = true;
    
    // –î–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –≤–µ–±–µ
    node->relay1State = (msg->relay1_state == 1);
    node->relay2State = (msg->relay2_state == 1);
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    if (DEBUG_MODE) {
        Serial.print("üì• –î–∞–Ω–Ω—ã–µ –æ—Ç " + node->name + ": ");
        Serial.print("V1=" + String(node->value1, 2));
        Serial.print(", V2=" + String(node->value2, 2));
        Serial.print(", R1=" + String(node->relay1_state));
        Serial.print(", R2=" + String(node->relay2_state));
        Serial.print(", RSSI=" + String(node->rssi));
        Serial.print(", Heap=" + String(node->freeHeap));
        Serial.println();
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ WebSocket
    sendWebSocketUpdate(index);
}

void checkNodeTimeouts() {
    unsigned long currentTime = millis();
    
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < nodeCount; i++) {
            if (nodes[i].online && (currentTime - nodes[i].lastSeen > NODE_TIMEOUT_MS)) {
                nodes[i].online = false;
                Serial.println("‚ùå –£–∑–µ–ª " + nodes[i].name + " –æ—Ñ—Ñ–ª–∞–π–Ω (—Ç–∞–π–º–∞—É—Ç)");
                
                // –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ WebSocket
                JsonDocument doc;
                doc["type"] = "node_offline";
                doc["nodeId"] = nodes[i].nodeId;
                
                String jsonStr;
                serializeJson(doc, jsonStr);
                ws.textAll(jsonStr);
            }
        }
        xSemaphoreGive(xNodesSemaphore);
    }
}

// 8. –§—É–Ω–∫—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö
bool sendEspNowCommand(uint32_t nodeId, uint8_t commandType, float val1, float val2) {
    int index = findNodeById(nodeId);
    if (index == -1) {
        Serial.println("‚ùå –£–∑–µ–ª —Å ID " + String(nodeId) + " –Ω–µ –Ω–∞–π–¥–µ–Ω");
        return false;
    }
    
    if (!nodes[index].espNowRegistered) {
        Serial.println("‚ùå –£–∑–µ–ª " + nodes[index].name + " –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ ESP-NOW");
        return false;
    }
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
    EspNowMessage msg;
    msg.sender_id = 1; // ID —Ö–∞–±–∞
    msg.command_type = commandType;
    msg.value1 = val1;
    msg.value2 = val2;
    msg.relay1_state = 0;
    msg.relay2_state = 0;
    msg.status = 0;
    msg.timestamp = millis();
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞
    esp_err_t result = esp_now_send(nodes[index].mac, (uint8_t*)&msg, sizeof(msg));
    
    if (result == ESP_OK) {
        Serial.println("üì§ –ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —É–∑–ª—É " + nodes[index].name);
        return true;
    } else {
        Serial.println("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã: " + String(esp_err_to_name(result)));
        return false;
    }
}

void sendWebSocketUpdate(int nodeIndex) {
    if (nodeIndex < 0 || nodeIndex >= nodeCount) return;
    
    JsonDocument doc;
    doc["type"] = "node_update";
    
    JsonObject nodeObj = doc.createNestedObject("node");
    nodeObj["nodeId"] = nodes[nodeIndex].nodeId;
    nodeObj["name"] = nodes[nodeIndex].name;
    nodeObj["nodeType"] = nodes[nodeIndex].nodeType;
    nodeObj["online"] = nodes[nodeIndex].online;
    nodeObj["value1"] = nodes[nodeIndex].value1;
    nodeObj["value2"] = nodes[nodeIndex].value2;
    nodeObj["relay1_state"] = nodes[nodeIndex].relay1_state;
    nodeObj["relay2_state"] = nodes[nodeIndex].relay2_state;
    nodeObj["rssi"] = nodes[nodeIndex].rssi;
    nodeObj["lastSeen"] = nodes[nodeIndex].lastSeen;
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤—Å–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–º –∫–ª–∏–µ–Ω—Ç–∞–º
    ws.textAll(jsonStr);
}

void broadcastSystemStatus() {
    JsonDocument doc;
    doc["type"] = "system_status";
    doc["wifi_connected"] = true;
    doc["free_heap"] = ESP.getFreeHeap();
    doc["uptime"] = millis() / 1000;
    doc["node_count"] = nodeCount;
    doc["online_count"] = 0;
    
    // –ü–æ–¥—Å—á–µ—Ç –æ–Ω–ª–∞–π–Ω —É–∑–ª–æ–≤
    if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < nodeCount; i++) {
            if (nodes[i].online) doc["online_count"] = doc["online_count"].as<int>() + 1;
        }
        xSemaphoreGive(xNodesSemaphore);
    }
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    ws.textAll(jsonStr);
}

// 9. JSON —Ñ—É–Ω–∫—Ü–∏–∏
String getNodesJSON() {
    JsonDocument doc;
    doc["type"] = "nodes_list";
    
    JsonArray nodesArray = doc.createNestedArray("nodes");
    
    for (int i = 0; i < nodeCount; i++) {
        JsonObject nodeObj = nodesArray.add<JsonObject>();
        nodeObj["nodeId"] = nodes[i].nodeId;
        nodeObj["name"] = nodes[i].name;
        nodeObj["nodeType"] = nodes[i].nodeType;
        nodeObj["online"] = nodes[i].online;
        nodeObj["value1"] = nodes[i].value1;
        nodeObj["value2"] = nodes[i].value2;
        nodeObj["relay1_state"] = nodes[i].relay1_state;
        nodeObj["relay2_state"] = nodes[i].relay2_state;
        nodeObj["rssi"] = nodes[i].rssi;
        nodeObj["lastSeen"] = nodes[i].lastSeen;
        nodeObj["mac"] = macToString(nodes[i].mac);
    }
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    return jsonStr;
}

String getNodeJSON(int index) {
    if (index < 0 || index >= nodeCount) {
        return "{\"error\":\"invalid_index\"}";
    }
    
    JsonDocument doc;
    doc["nodeId"] = nodes[index].nodeId;
    doc["name"] = nodes[index].name;
    doc["nodeType"] = nodes[index].nodeType;
    doc["online"] = nodes[index].online;
    doc["value1"] = nodes[index].value1;
    doc["value2"] = nodes[index].value2;
    doc["relay1_state"] = nodes[index].relay1_state;
    doc["relay2_state"] = nodes[index].relay2_state;
    doc["status"] = nodes[index].status;
    doc["rssi"] = nodes[index].rssi;
    doc["freeHeap"] = nodes[index].freeHeap;
    doc["lastSeen"] = nodes[index].lastSeen;
    doc["lastCommand"] = nodes[index].lastCommand;
    doc["lastCommandTime"] = nodes[index].lastCommandTime;
    doc["mac"] = macToString(nodes[index].mac);
    doc["ip"] = nodes[index].ip;
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    return jsonStr;
}

// 10. FreeRTOS –∑–∞–¥–∞—á–∏
void Task_WebServer(void* pvParameters) {
    Serial.println("‚úÖ –ó–∞–¥–∞—á–∞ WebServer –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ Core " + String(xPortGetCoreID()));
    
    for (;;) {
        // –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö WebSocket –∫–ª–∏–µ–Ω—Ç–æ–≤
        ws.cleanupClients();
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–π–º–∞—É—Ç–æ–≤ —É–∑–ª–æ–≤ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
        static unsigned long lastCheck = 0;
        if (millis() - lastCheck > 5000) {
            lastCheck = millis();
            checkNodeTimeouts();
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
        static unsigned long lastStatus = 0;
        if (millis() - lastStatus > 10000) {
            lastStatus = millis();
            broadcastSystemStatus();
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void Task_ESPNowLogic(void* pvParameters) {
    Serial.println("‚úÖ –ó–∞–¥–∞—á–∞ ESPNowLogic –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ Core " + String(xPortGetCoreID()));
    
    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –æ—Ç–ø—Ä–∞–≤–∫—É –∫–æ–º–∞–Ω–¥ —É–∑–ª–∞–º
    // –∏–ª–∏ –¥—Ä—É–≥–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ ESP-NOW
    
    for (;;) {
        // –ü—Ä–∏–º–µ—Ä: –æ—Ç–ø—Ä–∞–≤–∫–∞ ping –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        static unsigned long lastPing = 0;
        if (millis() - lastPing > 30000) {
            lastPing = millis();
            
            if (xSemaphoreTake(xNodesSemaphore, portMAX_DELAY) == pdTRUE) {
                for (int i = 0; i < nodeCount; i++) {
                    if (nodes[i].espNowRegistered) {
                        // –û—Ç–ø—Ä–∞–≤–∫–∞ ping —Å–æ–æ–±—â–µ–Ω–∏—è
                        sendEspNowCommand(nodes[i].nodeId, 1, 0, 0);
                    }
                }
                xSemaphoreGive(xNodesSemaphore);
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// 11. –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
void printNodeInfo(int index) {
    if (index < 0 || index >= nodeCount) return;
    
    Serial.println("=== –£–∑–µ–ª " + nodes[index].name + " ===");
    Serial.println("ID: " + String(nodes[index].nodeId));
    Serial.println("MAC: " + macToString(nodes[index].mac));
    Serial.println("–¢–∏–ø: " + String(nodes[index].nodeType));
    Serial.println("–°—Ç–∞—Ç—É—Å: " + String(nodes[index].online ? "Online" : "Offline"));
    Serial.println("V1: " + String(nodes[index].value1, 2));
    Serial.println("V2: " + String(nodes[index].value2, 2));
    Serial.println("R1: " + String(nodes[index].relay1_state));
    Serial.println("R2: " + String(nodes[index].relay2_state));
    Serial.println("RSSI: " + String(nodes[index].rssi) + " dBm");
    Serial.println("–ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: " + String((millis() - nodes[index].lastSeen) / 1000) + " —Å–µ–∫ –Ω–∞–∑–∞–¥");
    Serial.println("=============================");
}

String macToString(const uint8_t* mac) {
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    return String(macStr);
}
