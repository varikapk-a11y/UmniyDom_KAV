// ===================== CONFIGURATION =====================
// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ true –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –≤ Serial Monitor
#define DEBUG_MODE true

// MAC –∞–¥—Ä–µ—Å–∞ –≤–∞—à–∏—Ö —É–∑–ª–æ–≤ (–∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –≤–∞—à–∏ —Ä–µ–∞–ª—å–Ω—ã–µ MAC)
uint8_t node_mac_1[] = {0x88, 0x56, 0xA6, 0x7C, 0xF2, 0xA8}; // –£–∑–µ–ª #2 (PIR)
uint8_t node_mac_2[] = {0x88, 0x56, 0xA6, 0x7D, 0x09, 0x64}; // –£–∑–µ–ª #3 (–†–µ–ª–µ)
uint8_t node_mac_3[] = {0x10, 0x00, 0x3B, 0xB1, 0xA6, 0x9C}; // –£–∑–µ–ª #4 (RGB)
uint8_t node_mac_4[] = {0xAC, 0xEB, 0xE6, 0x49, 0x10, 0x28}; // –£–∑–µ–ª #5 (–î–∞—Ç—á–∏–∫ —Å–≤–µ—Ç–∞)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞
struct NodeData {
  uint8_t mac[6];
  String node_id;
  uint8_t node_type; // 1=DHT22, 2=PIR, 3=RELAY, 4=RGB, 5=LIGHT_SENSOR
  float value1;
  float value2;
  uint8_t relay1_state;
  uint8_t relay2_state;
  uint8_t status;
  unsigned long last_seen;
  bool online;
};

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –æ–±–æ–∏—Ö —è–¥—Ä–∞—Ö)
volatile NodeData nodes[4];
volatile bool newDataAvailable = false;
volatile uint8_t updatedNodeIndex = 0;

// ===================== CORE 0: NETWORK & WEB =====================
#include <WiFi.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <ESPmDNS.h>

WebServer server(80);
WebSocketsServer webSocket = WebSocketsServer(81);

// HTML —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (–≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –≤ –∫–æ–¥ - –ø—Ä–æ—â–µ —á–µ–º LittleFS)
const char* htmlPage = R"rawliteral(
<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Home Hub - ESP32-S3</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Arial, sans-serif; }
body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: #333; padding: 20px; }
.container { max-width: 1200px; margin: 0 auto; }
header { background: rgba(255,255,255,0.95); padding: 25px; border-radius: 15px; margin-bottom: 25px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
header h1 { color: #2d3748; font-size: 2.2em; margin-bottom: 10px; }
.status-bar { display: flex; gap: 25px; font-weight: 600; font-size: 1.1em; }
.status-online { color: #38a169; }
.status-offline { color: #e53e3e; }
.dashboard { display: flex; flex-direction: column; gap: 30px; }
.section { background: rgba(255,255,255,0.95); padding: 25px; border-radius: 15px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
.section h2 { margin-bottom: 20px; color: #2d3748; border-bottom: 3px solid #667eea; padding-bottom: 12px; font-size: 1.8em; }
.nodes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 25px; margin-top: 20px; }
.node-card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); transition: transform 0.3s, box-shadow 0.3s; border-left: 5px solid #667eea; }
.node-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
.node-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.node-id { font-size: 1.4em; font-weight: 700; color: #2d3748; }
.node-type { font-size: 0.9em; padding: 5px 15px; border-radius: 20px; color: white; font-weight: 600; }
.type-pir { background: #4299e1; }
.type-relay { background: #ed8936; }
.type-rgb { background: #9f7aea; }
.type-light { background: #48bb78; }
.node-data { margin: 15px 0; font-size: 1.1em; }
.data-row { display: flex; justify-content: space-between; margin: 8px 0; padding: 8px 0; border-bottom: 1px solid #e2e8f0; }
.data-label { color: #718096; }
.data-value { font-weight: 600; color: #2d3748; }
.relay-control { display: flex; gap: 15px; margin-top: 20px; }
.relay-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s; font-size: 1em; }
.btn-on { background: #48bb78; color: white; }
.btn-on:hover { background: #38a169; }
.btn-off { background: #f56565; color: white; }
.btn-off:hover { background: #e53e3e; }
.btn-toggle { background: #667eea; color: white; }
.btn-toggle:hover { background: #5a67d8; }
.node-footer { margin-top: 15px; padding-top: 15px; border-top: 1px solid #e2e8f0; display: flex; justify-content: space-between; font-size: 0.9em; }
.online-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
.dot-online { background: #48bb78; }
.dot-offline { background: #e53e3e; }
.last-seen { color: #a0aec0; }
.connection-status { position: fixed; bottom: 20px; right: 20px; padding: 15px 25px; border-radius: 10px; background: rgba(255,255,255,0.9); box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-weight: 600; }
.connected { border-left: 5px solid #48bb78; }
.disconnected { border-left: 5px solid #f56565; }
@media (max-width: 768px) { .nodes-grid { grid-template-columns: 1fr; } .container { padding: 10px; } }
</style>
</head>
<body>
<div class="container">
<header>
  <h1>üè† Smart Home Hub - ESP32-S3</h1>
  <div class="status-bar">
    <span id="wifi-status" class="status-offline">WiFi: –û—Ç–∫–ª—é—á–µ–Ω</span>
    <span id="nodes-count">–£–∑–ª–æ–≤: 0/4</span>
    <span id="ws-status" class="status-offline">WebSocket: –û—Ç–∫–ª—é—á–µ–Ω</span>
  </div>
</header>
<div class="dashboard">
  <section class="section">
    <h2>üì° –ë–µ—Å–ø—Ä–æ–≤–æ–¥–Ω—ã–µ —É–∑–ª—ã ESP-NOW</h2>
    <div class="nodes-grid" id="nodes-container">
      <!-- –£–∑–ª—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
    </div>
  </section>
</div>
<div id="connection-status" class="connection-status disconnected">
  üîå –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Ö–∞–±—É...
</div>
</div>
<script>
let socket;
const nodes = {};
function connectWebSocket() {
  const ip = window.location.hostname || "192.168.4.1";
  socket = new WebSocket(`ws://${ip}:81`);
  socket.onopen = () => {
    console.log("‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω");
    document.getElementById('ws-status').textContent = "WebSocket: –ü–æ–¥–∫–ª—é—á–µ–Ω";
    document.getElementById('ws-status').className = "status-online";
    document.getElementById('connection-status').className = "connection-status connected";
    document.getElementById('connection-status').innerHTML = "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Ö–∞–±—É";
    socket.send(JSON.stringify({cmd: "get_nodes"}));
  };
  socket.onclose = () => {
    console.log("‚ùå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω");
    document.getElementById('ws-status').textContent = "WebSocket: –û—Ç–∫–ª—é—á–µ–Ω";
    document.getElementById('ws-status').className = "status-offline";
    document.getElementById('connection-status').className = "connection-status disconnected";
    document.getElementById('connection-status').innerHTML = "üîå –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Ö–∞–±—É...";
    setTimeout(connectWebSocket, 3000);
  };
  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      handleMessage(data);
    } catch(e) {
      console.error("–û—à–∏–±–∫–∞ JSON:", e);
    }
  };
  socket.onerror = (error) => {
    console.error("WebSocket –æ—à–∏–±–∫–∞:", error);
  };
}
function handleMessage(data) {
  switch(data.event) {
    case 'nodes_list':
      updateNodesList(data.nodes);
      break;
    case 'node_update':
      updateNode(data);
      break;
    case 'node_offline':
      setNodeOffline(data.id);
      break;
    case 'system_status':
      document.getElementById('wifi-status').textContent = `WiFi: ${data.wifi_connected ? '–ü–æ–¥–∫–ª—é—á–µ–Ω' : '–û—Ç–∫–ª—é—á–µ–Ω'}`;
      document.getElementById('wifi-status').className = data.wifi_connected ? "status-online" : "status-offline";
      break;
  }
}
function updateNodesList(nodesList) {
  const container = document.getElementById('nodes-container');
  container.innerHTML = '';
  document.getElementById('nodes-count').textContent = `–£–∑–ª–æ–≤: ${nodesList.length}/4`;
  nodesList.forEach(node => {
    const nodeCard = createNodeCard(node);
    container.appendChild(nodeCard);
    nodes[node.id] = node;
  });
}
function updateNode(data) {
  if(nodes[data.id]) {
    nodes[data.id] = {...nodes[data.id], ...data};
    updateNodeCard(data.id);
  }
}
function setNodeOffline(nodeId) {
  if(nodes[nodeId]) {
    nodes[nodeId].online = false;
    updateNodeCard(nodeId);
  }
}
function createNodeCard(node) {
  const div = document.createElement('div');
  div.className = 'node-card';
  div.id = `node-${node.id}`;
  const typeNames = {2:'PIR –¥–∞—Ç—á–∏–∫',3:'–†–µ–ª–µ –º–æ–¥—É–ª—å',4:'RGB —Å–≤–µ—Ç',5:'–î–∞—Ç—á–∏–∫ —Å–≤–µ—Ç–∞'};
  const typeColors = {2:'type-pir',3:'type-relay',4:'type-rgb',5:'type-light'};
  let content = `<div class="node-header"><div class="node-id">${node.id}</div><span class="node-type ${typeColors[node.type]}">${typeNames[node.type]}</span></div>`;
  if(node.type === 2) {
    content += `<div class="node-data"><div class="data-row"><span class="data-label">–î–≤–∏–∂–µ–Ω–∏–µ:</span><span class="data-value">${node.value1==1?'–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ':'–ù–µ—Ç'}</span></div></div>`;
  } else if(node.type === 3) {
    content += `<div class="node-data">
      <div class="data-row"><span class="data-label">–†–µ–ª–µ 1:</span><span class="data-value">${node.relay1_state?'–í–ö–õ':'–í–´–ö–õ'}</span></div>
      <div class="data-row"><span class="data-label">–†–µ–ª–µ 2:</span><span class="data-value">${node.relay2_state?'–í–ö–õ':'–í–´–ö–õ'}</span></div>
    </div>
    <div class="relay-control">
      <button class="relay-btn btn-toggle" onclick="controlNode('${node.id}','toggle',1)">–ü–µ—Ä–µ–∫–ª. 1</button>
      <button class="relay-btn btn-on" onclick="controlNode('${node.id}','on',1)">–í–ö–õ 1</button>
      <button class="relay-btn btn-off" onclick="controlNode('${node.id}','off',1)">–í–´–ö–õ 1</button>
    </div>
    <div class="relay-control">
      <button class="relay-btn btn-toggle" onclick="controlNode('${node.id}','toggle',2)">–ü–µ—Ä–µ–∫–ª. 2</button>
      <button class="relay-btn btn-on" onclick="controlNode('${node.id}','on',2)">–í–ö–õ 2</button>
      <button class="relay-btn btn-off" onclick="controlNode('${node.id}','off',2)">–í–´–ö–õ 2</button>
    </div>`;
  } else if(node.type === 4) {
    content += `<div class="node-data"><div class="data-row"><span class="data-label">RGB —Å—Ç–∞—Ç—É—Å:</span><span class="data-value">${node.value1?'–ê–∫—Ç–∏–≤–µ–Ω':'–í—ã–∫–ª—é—á–µ–Ω'}</span></div></div>`;
  } else if(node.type === 5) {
    content += `<div class="node-data"><div class="data-row"><span class="data-label">–û—Å–≤–µ—â–µ–Ω–Ω–æ—Å—Ç—å:</span><span class="data-value">${node.value1.toFixed(1)}%</span></div></div>`;
  }
  content += `<div class="node-footer"><div><span class="online-dot ${node.online?'dot-online':'dot-offline'}"></span>${node.online?'Online':'Offline'}</div><div class="last-seen">–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${formatTime(node.last_seen)}</div></div>`;
  div.innerHTML = content;
  return div;
}
function updateNodeCard(nodeId) {
  const card = document.getElementById(`node-${nodeId}`);
  if(card && nodes[nodeId]) {
    const node = nodes[nodeId];
    const onlineDot = card.querySelector('.online-dot');
    if(onlineDot) onlineDot.className = `online-dot ${node.online?'dot-online':'dot-offline'}`;
    const statusText = card.querySelector('.node-footer div:first-child');
    if(statusText) statusText.innerHTML = `<span class="online-dot ${node.online?'dot-online':'dot-offline'}"></span>${node.online?'Online':'Offline'}`;
    const lastSeen = card.querySelector('.last-seen');
    if(lastSeen) lastSeen.textContent = `–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${formatTime(node.last_seen)}`;
    if(node.type === 2) {
      const motionValue = card.querySelector('.data-value');
      if(motionValue) motionValue.textContent = node.value1==1?'–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ':'–ù–µ—Ç';
    } else if(node.type === 3) {
      const relay1 = card.querySelectorAll('.data-value')[0];
      const relay2 = card.querySelectorAll('.data-value')[1];
      if(relay1) relay1.textContent = node.relay1_state?'–í–ö–õ':'–í–´–ö–õ';
      if(relay2) relay2.textContent = node.relay2_state?'–í–ö–õ':'–í–´–ö–õ';
    } else if(node.type === 4) {
      const rgbStatus = card.querySelector('.data-value');
      if(rgbStatus) rgbStatus.textContent = node.value1?'–ê–∫—Ç–∏–≤–µ–Ω':'–í—ã–∫–ª—é—á–µ–Ω';
    } else if(node.type === 5) {
      const lightValue = card.querySelector('.data-value');
      if(lightValue) lightValue.textContent = `${node.value1.toFixed(1)}%`;
    }
  }
}
function controlNode(nodeId, command, relayNum) {
  if(socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      cmd: "control_node",
      node_id: nodeId,
      command: command,
      relay_num: relayNum
    }));
  }
}
function formatTime(timestamp) {
  if(!timestamp) return "–Ω–∏–∫–æ–≥–¥–∞";
  const now = Date.now();
  const diff = now - timestamp;
  if(diff < 60000) return "—Ç–æ–ª—å–∫–æ —á—Ç–æ";
  if(diff < 3600000) return `${Math.floor(diff/60000)} –º–∏–Ω –Ω–∞–∑–∞–¥`;
  if(diff < 86400000) return `${Math.floor(diff/3600000)} —á –Ω–∞–∑–∞–¥`;
  return `${Math.floor(diff/86400000)} –¥–Ω –Ω–∞–∑–∞–¥`;
}
window.onload = function() {
  connectWebSocket();
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
  setInterval(() => {
    if(socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({cmd: "get_nodes"}));
    }
  }, 10000);
};
</script>
</body></html>
)rawliteral";

// ===================== WEB SERVER HANDLERS =====================
void handleRoot() {
  server.send(200, "text/html", htmlPage);
}

void handleNotFound() {
  server.send(404, "text/plain", "404: Not Found");
}

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_DISCONNECTED:
      if(DEBUG_MODE) Serial.printf("[%u] –û—Ç–∫–ª—é—á–µ–Ω\n", num);
      break;
    case WStype_CONNECTED:
      if(DEBUG_MODE) {
        IPAddress ip = webSocket.remoteIP(num);
        Serial.printf("[%u] –ü–æ–¥–∫–ª—é—á–µ–Ω –æ—Ç %d.%d.%d.%d\n", num, ip[0], ip[1], ip[2], ip[3]);
      }
      sendNodesList(num);
      break;
    case WStype_TEXT:
      processWebSocketCommand(num, payload, length);
      break;
  }
}

void processWebSocketCommand(uint8_t client_num, uint8_t *payload, size_t length) {
  String message = String((char*)payload).substring(0, length);
  if(DEBUG_MODE) Serial.printf("–ü–æ–ª—É—á–µ–Ω–æ: %s\n", message.c_str());
  
  DynamicJsonDocument doc(256);
  DeserializationError error = deserializeJson(doc, message);
  
  if(error) {
    if(DEBUG_MODE) Serial.println("–û—à–∏–±–∫–∞ JSON");
    return;
  }
  
  String cmd = doc["cmd"];
  
  if(cmd == "get_nodes") {
    sendNodesList(client_num);
  }
  else if(cmd == "control_node") {
    String node_id = doc["node_id"];
    String command = doc["command"];
    int relay_num = doc["relay_num"] | 1;
    
    // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —É–∑–µ–ª —á–µ—Ä–µ–∑ ESP-NOW (–≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞ Core 1)
    // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
    if(DEBUG_MODE) {
      Serial.printf("–ö–æ–º–∞–Ω–¥–∞ —É–∑–ª—É %s: %s —Ä–µ–ª–µ %d\n", 
                   node_id.c_str(), command.c_str(), relay_num);
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    String response = "{\"event\":\"command_ack\",\"node_id\":\"" + node_id + 
                     "\",\"command\":\"" + command + "\",\"relay\":" + String(relay_num) + "}";
    webSocket.sendTXT(client_num, response);
  }
}

void sendNodesList(uint8_t client_num = 255) {
  String json = "{\"event\":\"nodes_list\",\"nodes\":[";
  
  for(int i = 0; i < 4; i++) {
    if(i > 0) json += ",";
    json += "{";
    json += "\"id\":\"" + String(nodes[i].node_id) + "\",";
    json += "\"type\":" + String(nodes[i].node_type) + ",";
    json += "\"value1\":" + String(nodes[i].value1, 2) + ",";
    json += "\"value2\":" + String(nodes[i].value2, 2) + ",";
    json += "\"relay1_state\":" + String(nodes[i].relay1_state) + ",";
    json += "\"relay2_state\":" + String(nodes[i].relay2_state) + ",";
    json += "\"status\":" + String(nodes[i].status) + ",";
    json += "\"online\":" + String(nodes[i].online ? "true" : "false") + ",";
    json += "\"last_seen\":" + String(nodes[i].last_seen);
    json += "}";
  }
  
  json += "]}";
  
  if(client_num == 255) {
    webSocket.broadcastTXT(json);
  } else {
    webSocket.sendTXT(client_num, json);
  }
}

// ===================== CORE 1: ESP-NOW & NODE LOGIC =====================
#include <esp_now.h>
#include <esp_wifi.h>

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è ESP-NOW —Å–æ–æ–±—â–µ–Ω–∏–π
typedef struct __attribute__((packed)) {
  char node_id[32];
  uint8_t node_type;
  float value1;
  float value2;
  uint8_t relay1_state;
  uint8_t relay2_state;
  uint8_t status;
  uint32_t timestamp;
} espnow_message_t;

// Callback –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ—Ç —É–∑–ª–æ–≤
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  if(len == sizeof(espnow_message_t)) {
    espnow_message_t msg;
    memcpy(&msg, incomingData, sizeof(msg));
    
    // –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å —É–∑–ª–∞ –ø–æ MAC
    int node_index = -1;
    for(int i = 0; i < 4; i++) {
      if(memcmp(nodes[i].mac, mac, 6) == 0) {
        node_index = i;
        break;
      }
    }
    
    if(node_index != -1) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —É–∑–ª–∞
      nodes[node_index].value1 = msg.value1;
      nodes[node_index].value2 = msg.value2;
      nodes[node_index].relay1_state = msg.relay1_state;
      nodes[node_index].relay2_state = msg.relay2_state;
      nodes[node_index].status = msg.status;
      nodes[node_index].last_seen = millis();
      nodes[node_index].online = true;
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
      newDataAvailable = true;
      updatedNodeIndex = node_index;
      
      if(DEBUG_MODE) {
        Serial.printf("–î–∞–Ω–Ω—ã–µ –æ—Ç %s: v1=%.1f, v2=%.1f, r1=%d, r2=%d\n", 
                     msg.node_id, msg.value1, msg.value2, 
                     msg.relay1_state, msg.relay2_state);
      }
    }
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥ –Ω–∞ —É–∑–ª—ã
void sendCommandToNode(int node_index, String command, int relay_num) {
  // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–æ–º–∞–Ω–¥—ã –¥–ª—è ESP-NOW
  typedef struct __attribute__((packed)) {
    char command[16];
    int relay_num;
    int value;
  } node_command_t;
  
  node_command_t cmd;
  
  if(command == "on") {
    strcpy(cmd.command, "relay_on");
    cmd.value = 1;
  } else if(command == "off") {
    strcpy(cmd.command, "relay_off");
    cmd.value = 0;
  } else if(command == "toggle") {
    strcpy(cmd.command, "relay_toggle");
    cmd.value = 0;
  }
  
  cmd.relay_num = relay_num;
  
  // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É —á–µ—Ä–µ–∑ ESP-NOW
  esp_now_send(nodes[node_index].mac, (uint8_t*)&cmd, sizeof(cmd));
}

// ===================== TASK FUNCTIONS FOR EACH CORE =====================
TaskHandle_t Core0Task;
TaskHandle_t Core1Task;

void Core0code(void *pvParameters) {
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Wi-Fi –≤ —Ä–µ–∂–∏–º–µ —Ç–æ—á–∫–∏ –¥–æ—Å—Ç—É–ø–∞
  WiFi.mode(WIFI_AP);
  WiFi.softAP("SmartHomeHub", "12345678");
  
  if(DEBUG_MODE) {
    Serial.print("AP IP address: ");
    Serial.println(WiFi.softAPIP());
  }
  
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
  server.on("/", handleRoot);
  server.onNotFound(handleNotFound);
  server.begin();
  
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ WebSocket
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  
  if(DEBUG_MODE) Serial.println("Core 0: Web —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω");
  
  // –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ HTTP –∏ WebSocket
  for(;;) {
    server.handleClient();
    webSocket.loop();
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç —É–∑–ª–æ–≤ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞–º
    if(newDataAvailable) {
      String update = "{";
      update += "\"event\":\"node_update\",";
      update += "\"id\":\"" + String(nodes[updatedNodeIndex].node_id) + "\",";
      update += "\"value1\":" + String(nodes[updatedNodeIndex].value1, 2) + ",";
      update += "\"value2\":" + String(nodes[updatedNodeIndex].value2, 2) + ",";
      update += "\"relay1_state\":" + String(nodes[updatedNodeIndex].relay1_state) + ",";
      update += "\"relay2_state\":" + String(nodes[updatedNodeIndex].relay2_state) + ",";
      update += "\"status\":" + String(nodes[updatedNodeIndex].status);
      update += "}";
      
      webSocket.broadcastTXT(update);
      newDataAvailable = false;
    }
    
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}

void Core1code(void *pvParameters) {
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ESP-NOW
  if(esp_now_init() != ESP_OK) {
    if(DEBUG_MODE) Serial.println("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ESP-NOW");
    vTaskDelete(NULL);
  }
  
  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è callback'–∞ –ø—Ä–∏—ë–º–∞
  esp_now_register_recv_cb(OnDataRecv);
  
  // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∏—Ä–æ–≤ (—É–∑–ª–æ–≤)
  for(int i = 0; i < 4; i++) {
    esp_now_peer_info_t peerInfo;
    memset(&peerInfo, 0, sizeof(peerInfo));
    memcpy(peerInfo.peer_addr, nodes[i].mac, 6);
    peerInfo.channel = 1;
    peerInfo.encrypt = false;
    
    if(esp_now_add_peer(&peerInfo) != ESP_OK) {
      if(DEBUG_MODE) Serial.printf("–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É–∑–ª–∞ %d\n", i);
    }
  }
  
  if(DEBUG_MODE) Serial.println("Core 1: ESP-NOW –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
  
  // –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ —É–∑–ª–æ–≤
  for(;;) {
    unsigned long current_time = millis();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–∏–µ —É–∑–ª—ã offline (–Ω–µ –±—ã–ª–æ –¥–∞–Ω–Ω—ã—Ö –±–æ–ª–µ–µ 30 —Å–µ–∫—É–Ω–¥)
    for(int i = 0; i < 4; i++) {
      if(nodes[i].online && (current_time - nodes[i].last_seen > 30000)) {
        nodes[i].online = false;
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ WebSocket (—á–µ—Ä–µ–∑ —Ñ–ª–∞–≥)
        newDataAvailable = true;
        updatedNodeIndex = i;
        
        if(DEBUG_MODE) Serial.printf("–£–∑–µ–ª %s –æ—Ç–∫–ª—é—á–∏–ª—Å—è\n", nodes[i].node_id.c_str());
      }
    }
    
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

// ===================== SETUP & MAIN LOOP =====================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  if(DEBUG_MODE) {
    Serial.println("\n=== SMART HOME HUB ESP32-S3 ===\n");
    Serial.println("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã...");
  }
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–æ–≤
  // –£–∑–µ–ª 1 (PIR)
  memcpy(nodes[0].mac, node_mac_1, 6);
  nodes[0].node_id = "PIR_Corridor";
  nodes[0].node_type = 2;
  nodes[0].relay1_state = 0;
  nodes[0].relay2_state = 0;
  nodes[0].online = false;
  
  // –£–∑–µ–ª 2 (–†–µ–ª–µ)
  memcpy(nodes[1].mac, node_mac_2, 6);
  nodes[1].node_id = "Relay_LivingRoom";
  nodes[1].node_type = 3;
  nodes[1].relay1_state = 0;
  nodes[1].relay2_state = 0;
  nodes[1].online = false;
  
  // –£–∑–µ–ª 3 (RGB)
  memcpy(nodes[2].mac, node_mac_3, 6);
  nodes[2].node_id = "RGB_Bedroom";
  nodes[2].node_type = 4;
  nodes[2].relay1_state = 0;
  nodes[2].relay2_state = 0;
  nodes[2].online = false;
  
  // –£–∑–µ–ª 4 (–î–∞—Ç—á–∏–∫ —Å–≤–µ—Ç–∞)
  memcpy(nodes[3].mac, node_mac_4, 6);
  nodes[3].node_id = "LightSensor";
  nodes[3].node_type = 5;
  nodes[3].relay1_state = 0;
  nodes[3].relay2_state = 0;
  nodes[3].online = false;
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —è–¥—Ä–∞
  xTaskCreatePinnedToCore(
    Core0code,   // –§—É–Ω–∫—Ü–∏—è –∑–∞–¥–∞—á–∏
    "Core0_Task",// –ò–º—è –∑–∞–¥–∞—á–∏
    10000,       // –†–∞–∑–º–µ—Ä —Å—Ç–µ–∫–∞
    NULL,        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    1,           // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç
    &Core0Task,  // –•—ç–Ω–¥–ª –∑–∞–¥–∞—á–∏
    0            // –Ø–¥—Ä–æ 0
  );
  
  xTaskCreatePinnedToCore(
    Core1code,   // –§—É–Ω–∫—Ü–∏—è –∑–∞–¥–∞—á–∏
    "Core1_Task",// –ò–º—è –∑–∞–¥–∞—á–∏
    10000,       // –†–∞–∑–º–µ—Ä —Å—Ç–µ–∫–∞
    NULL,        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    1,           // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç
    &Core1Task,  // –•—ç–Ω–¥–ª –∑–∞–¥–∞—á–∏
    1            // –Ø–¥—Ä–æ 1
  );
  
  if(DEBUG_MODE) Serial.println("–°–∏—Å—Ç–µ–º–∞ –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ –¥–≤—É—Ö —è–¥—Ä–∞—Ö");
}

void loop() {
  // –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ –∑–∞–¥–∞—á–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —è–¥—Ä–∞—Ö
  vTaskDelete(NULL);
}
